<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Dedication]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://wattlebird.github.io//"/>
  <updated>2016-10-11T09:57:51.287Z</updated>
  <id>http://wattlebird.github.io//</id>
  
  <author>
    <name><![CDATA[Ronnie Wang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Max flow, minimum cut]]></title>
    <link href="http://wattlebird.github.io/2016/10/11/Max-flow-minimum-cut/"/>
    <id>http://wattlebird.github.io/2016/10/11/Max-flow-minimum-cut/</id>
    <published>2016-10-11T09:53:04.000Z</published>
    <updated>2016-10-11T09:57:51.287Z</updated>
    <content type="html"><![CDATA[<p>在微软苏州已经入职了一个月了，生活开始渐渐稳定下来。和在北京的各种不堪相比，我要感谢这次调职，得以让我从 easy 模式开始社畜生活。同时搁置好久的算法又可以得以继续研究下去了。</p>
<p>今天讲的算法是最大流最小割算法。实际上这个是我在《算法导论》上看来看去都看不明白的一个章节：术语太多，而且代码很少（我好菜啊）。幸运的是，hihoCoder 上面的一系列专题为我垫了不少砖头，让我得以掌握这一块知识。</p>
<p>对于一个最大流问题，其定义一般都是这样的：有一个有向图 G，源点为 s，汇点为 t，每条边都有其对应的流最大容量 c，源点 s 只有发出的流量，汇点 t 只有汇入的流量，求能从源点到汇点的最大可能流量。</p>
<p>那么，我先不想说证明过程，我直接给出结论：我们用一种反复查找的方法，试图在当前图 G 上找到一条从 s 到 t 的路径，其边上允许的流量非零。每次找到这一条路径之后，也就可以确定这条路径上的流量瓶颈，将路径上的边的可行流量减去这一流量瓶颈，在新图上进行下一次查找。我们一直持续这样的查找，直到无法从 s 到 t 走出一条流量瓶颈大于 0 的路径。这个算法叫做 Ford-Fulkerson 算法。这个查找方式可以使用 BFS 进行。</p>
<p>嘛，基本上就是这样。但是由于图中可能会存在反向边，对于我上面讲的这个情况，对于下面这种情况是不成立的：</p>
<p><img src="flow.jpg" alt="An tricky example of flow network"></p>
<p>如果我们用 BFS 找到了 A-B-D-F 这条可行路径，其瓶颈是 3，减去该瓶颈之后无法找到更新的路径。然而其最大流是 5：由 B 分出的流量有一份到 D，另外两份到 E，然后 A-C-D 有一个流量为 2 的路径。这时候，我们需要一个“残余网络”的概念帮助我们解决这个问题：每条边维护一条对应的反向边，其大小为当前在正向上面已经消耗掉的流量，而正向边的容量为当前正向剩余的可行流量。换句话说，正向边和反向边的存在，帮助我们维护了每条边还有多少剩余流量可用。如果有一条流量容量为 1 的边，其正向流量为 1000000，反向流量为 999999，这也是可行的！我们在残余网络上找到的一条可行路径，叫做增广路径。于是我上面描述的算法可以如下表达：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">While ( findAugmentPath() ) <span class="comment">// 判断是否有增广路</span></span><br><span class="line">	maxFlow = maxFlow + delta <span class="comment">// 最大流增加</span></span><br><span class="line">	modifyGraph() <span class="comment">// 对增广路进行修改</span></span><br><span class="line">End While</span><br></pre></td></tr></table></figure>
<h2 id="与最小割的关系">与最小割的关系</h2><p>我们通常说 max flow, minimun cut。那么什么被定义为 cut？在一个带有 s 和 t 的网络流里，有一种划分把点划分到两个不相交的 S 和 T 集合中，$s \in S, t \in T$. 净流 f(S, T) 被定义为穿过割 (S, T) 的流量之和（当一个割经过反向边的时候，反向边上的流量应为负值）。割的容量 C(S, T) 被定义为这条割上所有的容量之和（不包括反向边）。也就是说，$f(S, T) \le C(S, T)$。 可以证明，当前网络的流量总是等于任意一个割的净流。但是，任意的割不会有相同的容量。其中最小的那个割的容量对应的割，我们称之为最小割。</p>
<p>现在有一个结论：对于任意网络流图来说，最大流一定等于最小割的容量。这个结论是最大流最小割定理的直接推论，这个定理由三个等价的表达组成：</p>
<ol>
<li>f 是网络的最大流；</li>
<li>该网络的残余网络不包含任何增广路径。</li>
<li>流网络的某个切割 (S, T) 的容量等于 f。</li>
</ol>
<p>因此，求出了最大流，也就求出了最小割的最大容量。使用上文所提及的 Ford-Fulkerson 算法，能够快速算出割、网络流量。</p>
<h2 id="Production_Code">Production Code</h2><p>使用 BFS 进行每次增广路径查找的 Ford-Fulkerson 实现叫做 Edmonds-Karp 算法。由于 BFS 时间复杂度（约）为 O(E)，流量递增操作的总次数为 O(VE)，该算法的时间复杂度为 $O(VE^2)$。这并不是最快的算法。现在有一种算法，通过记录每个点到汇点 t 的最短距离维持搜索顺序，使用 DFS 的方法进行增广路径的查找，能大大降低时间复杂度。这一算法的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本代码对应于 http://hihocoder.com/problemset/problem/1369</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">505</span>, maxm = <span class="number">40005</span>;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">int</span> u, v, c, prev;</span><br><span class="line">&#125;<span class="keyword">edge_t</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">edge_t</span> edges[maxm];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> source, sink;</span><br><span class="line"><span class="keyword">int</span> dep[maxn], depcnt[maxn], cur[maxn], <span class="built_in">stack</span>[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">	edges[id].u = u; edges[id].v = v; edges[id].c = c; edges[id].prev = head[u]; head[u] = id++;</span><br><span class="line">	edges[id].u = v; edges[id].v = u; edges[id].c = <span class="number">0</span>; edges[id].prev = head[v]; head[v] = id++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dep, <span class="number">0xff</span>, <span class="keyword">sizeof</span>(dep));</span><br><span class="line">	<span class="built_in">memset</span>(depcnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(depcnt));</span><br><span class="line">	dep[sink] = <span class="number">0</span>;</span><br><span class="line">	depcnt[dep[sink]] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.push(sink);</span><br><span class="line">	<span class="keyword">int</span> u, v;</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		u = Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> e = head[u]; ~e; e = edges[e].prev) <span class="keyword">if</span> (edges[e].c == <span class="number">0</span> &amp;&amp; dep[edges[e].v] == -<span class="number">1</span>) &#123;</span><br><span class="line">			v = edges[e].v;</span><br><span class="line">			Q.push(v);</span><br><span class="line">			dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">			depcnt[dep[v]]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SAP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	bfs();</span><br><span class="line">	<span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span>(head));</span><br><span class="line">	<span class="keyword">int</span> u = source, maxflow = <span class="number">0</span>, top = <span class="number">0</span>, i;</span><br><span class="line">	<span class="keyword">while</span> (dep[source]&lt;N) &#123;</span><br><span class="line">		<span class="keyword">if</span> (u == sink) &#123;</span><br><span class="line">			<span class="comment">//find the bottleneck</span></span><br><span class="line">			<span class="keyword">int</span> delta = inf, p;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> t = top - <span class="number">1</span>; t &gt;= <span class="number">0</span>; t--) &#123;</span><br><span class="line">				<span class="keyword">int</span> e = <span class="built_in">stack</span>[t];</span><br><span class="line">				<span class="keyword">if</span> (edges[e].c&lt;delta) &#123;</span><br><span class="line">					delta = edges[e].c;</span><br><span class="line">					p = t;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> t = top - <span class="number">1</span>; t &gt;= <span class="number">0</span>; t--) &#123;</span><br><span class="line">				<span class="keyword">int</span> e = <span class="built_in">stack</span>[t];</span><br><span class="line">				edges[e].c -= delta;</span><br><span class="line">				edges[e ^ <span class="number">1</span>].c += delta;</span><br><span class="line">			&#125;</span><br><span class="line">			maxflow += delta;</span><br><span class="line">			top = p;</span><br><span class="line">			u = edges[<span class="built_in">stack</span>[p]].u;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (i = cur[u]; ~i; i = edges[i].prev) &#123;</span><br><span class="line">			<span class="keyword">if</span> (edges[i].c&gt;<span class="number">0</span> &amp;&amp; dep[edges[i].v] == dep[u] - <span class="number">1</span>) &#123;</span><br><span class="line">				cur[u] = i;</span><br><span class="line">				u = edges[i].v;</span><br><span class="line">				<span class="built_in">stack</span>[top++] = i;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i == -<span class="number">1</span>) &#123;</span><br><span class="line">			depcnt[dep[u]]--;</span><br><span class="line">			<span class="keyword">if</span> (depcnt[dep[u]] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">int</span> mindep = N;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> e = head[u]; ~e; e = edges[e].prev) &#123;</span><br><span class="line">				<span class="keyword">if</span> (edges[e].c&gt;<span class="number">0</span> &amp;&amp; mindep &gt; dep[edges[e].v]) &#123;</span><br><span class="line">					mindep = dep[edges[e].v];</span><br><span class="line">					cur[u] = e;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			dep[u] = mindep + <span class="number">1</span>;</span><br><span class="line">			depcnt[dep[u]]++;</span><br><span class="line">			<span class="keyword">if</span> (u != source) &#123;</span><br><span class="line">				u = edges[<span class="built_in">stack</span>[--top]].u;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"testcase"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M);</span><br><span class="line">	source = <span class="number">1</span>, sink = N;</span><br><span class="line">	<span class="built_in">memset</span>(head, <span class="number">0xff</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v, c;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;c);</span><br><span class="line">		addedge(u, v, c);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, SAP());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嘛，这个优化后的算法叫什么我也不知道，我只是从别人的解法里学习过来的。但是这个代码做了至少这么几个工作：</p>
<ol>
<li>在进行 DFS 寻找增广路径之前用 BFS 从汇点搜索建立 dep 和 depcnt，即到汇点的最短距离，这样为在 DFS 的时候总是走最短路径提供了依据。</li>
<li>正向边和反向边成对存储，索引为偶数的总是正向边；正向边和反向边可以通过索引的异或切换；</li>
<li>stack 里面存储通过 DFS 寻找的增广路径。</li>
<li>在每一次 DFS 寻找过后，回溯到瓶颈路径的起点重新搜索，节省时间；</li>
<li>维护一个 cur，其在物理意义上与 head 相同，也是为了直接从当前的可行边搜索，节省时间；</li>
<li>但是如果从某点找不到可行边，需要更新该点的 dep 与 depcnt。这也就意味着 cur 也要更新。</li>
</ol>
<p>就是这样！但是有的文献指出，第一步建立 dep 与 depcnt 可以不进行。这主要的实现参考 <a href="http://hihocoder.com/contest/hiho117/solution/898175。" target="_blank" rel="external">http://hihocoder.com/contest/hiho117/solution/898175。</a></p>
<p>主要参考文献：</p>
<ol>
<li>hihocoder hiho一下 115、116、117、118、119 周</li>
<li>《算法导论》（第三版）第 26 章</li>
<li><a href="http://www.cnblogs.com/longdouhzt/archive/2012/05/13/2497770.html" target="_blank" rel="external">Max Flow-SAP-Improved Shortest Augmenting</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>在微软苏州已经入职了一个月了，生活开始渐渐稳定下来。和在北京的各种不堪相比，我要感谢这次调职，得以让我从 easy 模式开始社畜生活。同时搁置好久的算法又可以得以继续研究下去了。</p>
<p>今天讲的算法是最大流最小割算法。实际上这个是我在《算法导论》上看来看去都看不明白]]>
    </summary>
    
      <category term="Algorithm" scheme="http://wattlebird.github.io/tags/Algorithm/"/>
    
      <category term="C++" scheme="http://wattlebird.github.io/tags/C/"/>
    
      <category term="Max flow" scheme="http://wattlebird.github.io/tags/Max-flow/"/>
    
      <category term="Minimun cut" scheme="http://wattlebird.github.io/tags/Minimun-cut/"/>
    
      <category term="OJ review" scheme="http://wattlebird.github.io/categories/OJ-review/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[滴滴算法大赛总结]]></title>
    <link href="http://wattlebird.github.io/2016/06/18/%E6%BB%B4%E6%BB%B4%E7%AE%97%E6%B3%95%E5%A4%A7%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    <id>http://wattlebird.github.io/2016/06/18/滴滴算法大赛总结/</id>
    <published>2016-06-18T02:31:06.000Z</published>
    <updated>2016-06-17T22:10:16.731Z</updated>
    <content type="html"><![CDATA[<p><a href="http://research.xiaojukeji.com/competition/main.action?competitionId=DiTech2016&amp;&amp;locale=zh_CN" target="_blank" rel="external">滴滴算法大赛</a>是一场旨在预测城市交通供给需求不平衡程度的机器学习比赛。这个比赛的赛题是给定待预测的时间节点，预测整个城市在不同区块中需求与供给的差异 gap. 最终的比赛衡量方式是</p>
<span>$$\begin{equation}
MAPE = \frac{1}{D}\sum_{d=1}^{D}\left( \frac{1}{T} \sum_{t=1}^{T} \left| \frac{gap_{dt}-s_{dt}}{gap_{dt}}\right|\right) \forall gap_{dt}>0
\end{equation}$$</span><!-- Has MathJax -->
<p>在比赛中，D = 66，T = 144. 官方给出的训练数据有前三个星期的全部订单，天气和路况描述，区块属性描述。</p>
<p>我对该大赛的代码在<a href="https://github.com/wattlebird/ditech" target="_blank" rel="external">这里</a>。下面我来描述一下我的解决方案。</p>
<h2 id="特征提取">特征提取</h2><p>在这场比赛中我只使用订单的训练数据，无视天气、路况和区块属性数据。理由是天气、路况和区块属性最终还是会反映在订单上面。所以着重描绘订单反映的特征就可以了。我提取了如下八类特征，全部以 one-hot coding 方式呈现：</p>
<ol>
<li>订单所处时间是哪一小时（24维）</li>
<li>订单时间是否为双休日（2维）</li>
<li>订单地点在哪一区块（66维）</li>
<li>7 天前同一时间槽供求状况（21维）</li>
<li>订单所处时间的前一时间槽供求状况（21维）</li>
<li>订单前两个时间槽组合供求缺口状况（49维）</li>
<li>订单前三个时间槽的平均缺口状况（7维）</li>
<li>订单前三个时间槽的缺口标准差状况（3维）</li>
</ol>
<p>“时间槽”是赛题预先定义的把一整天时间划分为 144 个时间片的每一个时间片。为了用 one-hot coding 的方式描述供求，我使用如下的方式重新定义 gap：将 gap 以 [0,0],(0,1],(1,3],(3,6],(6,12],(12,30],(30,$+\infty$) 划分，形成 7 维特征。同时将需求（也就是客户发单数）以 [0,10],(10,20],(20,$+\infty$) 划分，形成 3 维特征。对于 21 维的“供求状况”，则使用 2d feature 的方式将两个特征相组合。对于“缺口状况”，则是将两个 gap 以 2d feature 的方式相组合，形成 49 维特征。对于缺口的标准差，则使用 [0,1],(1,5],(5,$+\infty$) 划分，形成 3 维特征。</p>
<p>但是这是远远不够的。比如说，我们想要设计的特征，能够包含一个区块在不同时间槽上的变化，这时候就必须结合时间特征和区域特征做二维特征。于是可以对所有这八类特征相互组合形成二维特征，最终形成一个一万多维的、非常稀疏特征。如果这时候按照这个特征训练一个线性回归模型，可以在测试集上面达到 0.32-0.34 的结果。但是实际上在应用的时候，并非八种特征完全相互组合，而是选取有物理意义的组合，以减少参数个数。代码中通过使用矩阵作为 mask 指定哪几类特征组合是被允许的。</p>
<p>我们还有一维特征，使用量的大小而非 one-hot coding：训练一个线性回归模型，预测的结果形成最后一维特征。这个特征也可以与先前的八类特征相互组合形成二维特征。</p>
<h2 id="建模">建模</h2><p>一开始我使用 scikit-learn 的线性回归模型建模的，但是这个库可能偏离了实用性。对于稀疏的 feature，我非常希望能有一范数做正则项，但是 scikit-learn 里面没有一个模型是符合我的要求的。而且，对于题目中要求的 metric，最好是对每一个训练样本进行 $\frac{1}{gap_{dt}}$的加权。并不是所有的模型在 scikit-learn 里面都有加权的选项。</p>
<p>其实最好的工具是 xgboost。这是一个基于残差迭代方法的、专门应用于机器学习竞赛的库。通过使用基于 GBDT 的回归模型，可以达到 0.29 左右的结果。需要指出的是，我发现三次残差迭代的效果是最好的，几乎颠覆了我以前对 GBDT 的印象。</p>
<h2 id="训练">训练</h2><p>我选取了元月 4 日、9 日、17 日、19 日和 21 日的全天数据作为 validation，其余的去除元月 1-3 日的数据作为 training. 同时复制 10 日和 16 日的记录一遍。</p>
<p>需要指出的是，在训练的时候要去除 gap=0 的数据，因为这些数据对评价标准没有任何影响（如果真的像评价标准那样定义的话）而且还会对模型产生 bias。</p>
<h2 id="可能存在的问题">可能存在的问题</h2><p><a href="https://twitter.com/haruki_kirigaya/status/737212998872244224" target="_blank" rel="external">先前有报导显示</a>，直接下载提交的测试文件就能达到 0.6 的 level，而按照定义，这样的测试文件应该生成 1 的 MAPE。可能我在我的 MAPE 计算程序里面有与官方理解不一致的地方。</p>
<h2 id="总结">总结</h2><p>我原来以为这个题目还是比较简单的，因为就是一个纯纯的监督学习问题。但是我发现我与最高水平的差距还是挺大。不论是实力还是客观条件方面都与别人的队伍有着较大的差距。最为愤怒的是，在前一天我在知乎上面看到有人说使用前三个时间槽的 gap 进行加权平均就能达到 0.29 的结果，我非常愤怒。我为了达到这个值花了这么多时间和精力，竟然还不如别人这么简单的无脑方法？？？如果能有更多的人和我团队合作，我们的思路就会越来越开阔，不至于像我走这种死胡同。</p>
<p>而且，我并非从一开始就参加这个竞赛，而是在硕士学位答辩完成之后才想着去“玩一玩”的。先前看到过 <a href="https://twitter.com/haruki_kirigaya" target="_blank" rel="external">@haruki_kirigaya</a> 也在玩这个（不过我要说，我没有看任何人的代码）。第一次提交是在 6 月 9 号，只有十次提交机会，而且中间还换了一次数据。不过，借口是无穷多的，实力的差距是绝对的。这也是我参加的第一次机器学习竞赛。我上次看到一个 Bangumi 上的人 fo 了我（我这种弱渣垃圾有什么好 fo 的），人家声称坚持打过每一场 Kaggle 竞赛，我真是无地自容。还是看书去吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://research.xiaojukeji.com/competition/main.action?competitionId=DiTech2016&amp;&amp;locale=zh_CN" target="_blank" rel="exte]]>
    </summary>
    
      <category term="Machine Learning" scheme="http://wattlebird.github.io/tags/Machine-Learning/"/>
    
      <category term="Competition" scheme="http://wattlebird.github.io/categories/Competition/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用 rankit 构建更科学的排名]]></title>
    <link href="http://wattlebird.github.io/2016/02/05/%E4%BD%BF%E7%94%A8-rankit-%E6%9E%84%E5%BB%BA%E6%9B%B4%E7%A7%91%E5%AD%A6%E7%9A%84%E6%8E%92%E5%90%8D/"/>
    <id>http://wattlebird.github.io/2016/02/05/使用-rankit-构建更科学的排名/</id>
    <published>2016-02-05T13:21:33.000Z</published>
    <updated>2016-02-05T14:12:00.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/wattlebird/ranking" target="_blank" rel="external">rankit</a> 是一个使用线性代数和最优化理论为基础的常见排名算法库。这个库是我写的。我说“常见”其实对于绝大部分人来说根本就闻所未闻，但是对于专门研究排名的研究者来说，这里面包含的算法都是比较基础的。自从阅读了一本介绍排名的书籍<a href="https://book.douban.com/subject/25915707/" target="_blank" rel="external">《谁排第一？关于评价和排序的科学》</a>之后，我觉得很有必要把这里面的宝藏介绍给对此一无所知的研究者。作为一个做与机器学习相关研究的研究生，竟然除了 PageRank 和 HITS 其他排名算法一个都没有听说过——课上不教，研究也涉及不到——因为生活中应用这些排名算法的场景，实在是很少接触到。然而，这些排名算法正在美国的体育比赛排名中大行其道。在那本书中，大部分案例直接来源于美国的橄榄球比赛排名。</p>
<p>然而要我把这本书里面所有的算法都介绍出来，实在是一件难事，一是有侵犯版权的嫌疑，二是其中涉及到大量的数学推导。我在此也只能简单地说一下。每一个排名（rank）由一个既定的评分（rating）产生，评分可以被解释为被排名对象的实力。在一定数学模型的指导下，被排名对象产生了比赛结果。这时候，可以看作 rating 这一因素导致了外在的比赛结果的观测值，这和 state 与 observation 的关系是一样的。根据不同的数学模型，就有了不同的 rating 算法。另外还有一个排名算法不依靠于 rating 数值，它试图给出一个 ranking，使得该排名与比赛的结果最为相符，说白了就是 linear ordering problem.</p>
<p>那么这种排名算法对我们有什么启示呢？现实生活中好像没有多少排名问题能够用被排名对象之间的比赛来表达啊。搜索引擎的网页排名能用 in-link 和 out-link 表达网页之间的关系，但是网页之间怎么进行比赛呢？事实上，这本书能够拓宽人的眼界的地方就在于此。如果在一个网页排名结果中，网页点击量的大小可以视作在这一场比赛中的结果。网页流量的大小也是网页实力的一个外在特征。在商品排名中，同时购买两件商品的人的评分综合也可以被视为两件商品比赛的结果。事实上，我们应该抛弃“比赛”这种概念，对两个排名对象在同等条件下比较的结果进行 fitting 要远远稳定于计算一个平均分，或是加权平均的结果。</p>
<h2 id="小白怎样使用_rankit？">小白怎样使用 rankit？</h2><p>rankit 提供了 Converter，只要用户能提供排名对象的每一轮的比赛结果（用 pandas.DataFrame 表示并包含特定的 columns），就能够为后续的算法计算出矩阵。在不同的数学模型下，需要的观测值就会有所不同。每一个算法都有它的物理意义，那么使用某一个算法要使用与其物理意义相对应的矩阵。比如说对于 MarkovRank 来说，这种算法需要表示排名对象之间相互投票的结果。我在 rankit 里面专门提供了 RateDifferenceVoteMatrix，SimpleDifferenceVoteMatrix 和 RateVoteMatrix 把观测到的评分结果表示成这样的矩阵。对于算法适用于什么样的矩阵这个问题，我在 rankit 的 GitHub 主页上面已经给出了参考表格。</p>
<p>rankit 还提供了排名融合的算法，排名融合能够使多种算法的排名更加稳定。用户也可以自行构建排名加入排名融合器，生成融合后的排名。另外，如果要比较排名之间的结果，rankit 还提供了两种测度描述排名列表之间的差距。</p>
<p>尽管我接口做得比较人性化了，我还是希望有一定背景知识的人去操纵这些算法。</p>
<h2 id="为_Bangumi_动画排名！">为 Bangumi 动画排名！</h2><p>长久以来，Bangumi 用户对 Bangumi 的动画排名争论不休<a href="http://chii.in/blog/269600" target="_blank" rel="external">[1]</a><a href="http://chii.in/blog/269560" target="_blank" rel="external">[2]</a>。由于 Bangumi 网站的高质量，某些别有用心人士试图通过刷分提高某些动画的排名或降低某些动画的排名，达到自己不可告人的宗教和政治目的<a href="http://chii.in/group/topic/337530" target="_blank" rel="external">[3]</a><a href="http://chii.in/group/topic/311903" target="_blank" rel="external">[4]</a><a href="http://chii.in/blog/270420" target="_blank" rel="external">[5]</a>。除此以外，有用户建议使用更为细致化的排名系统<a href="http://chii.in/group/topic/13906" target="_blank" rel="external">[6]</a><a href="http://chii.in/blog/48952" target="_blank" rel="external">[7]</a>，但是所有这些讨论都没有超出统计学的范畴，最多也只是在平均分上做些加加减减，或是玩一些加权的把戏。一个综合的讨论收录可以参考<a href="http://chii.in/group/topic/41475" target="_blank" rel="external">[8]</a>.</p>
<p>我们提出了一种全新的基于不同数学模型的排名方法，这些排名方法通过比较每两部作品的表现评分。同时看过两部作品的用户，我们可以计算他们为这两部作品评分的算术平均分、对数几何平均分和倾向性概率，从而生成三种作品间两两比较的实力数据。接着，对于每一种生成方法，我们使用八种不同的算法对作品进行排名。这些排名算法由 rankit 提供技术支撑。对于生成的 24 种排名，我们使用 Borda Count 融合所有排名，生成最终的动画排名。这 8 种算法分别是：</p>
<ol>
<li>Colley Rank (colley)</li>
<li>Massey Rank (massey)</li>
<li>Difference Rank (differ)</li>
<li>Markov Rank, using rate vote matrix as input (markov_rv)</li>
<li>Markov Rank, using rate difference vote matrix as input (markov_rdv)</li>
<li>Markov Rank, using simple difference vote matrix as input (markov_sdv)</li>
<li>Offence-defence Rank (od)</li>
<li>Keener Rank (no bias) (keener)</li>
</ol>
<p>使用基于算术平均的排名使用 ariavg 做前缀，使用基于对数几何平均的排名使用 geoavg 做前缀，使用概率的排名我们使用 prob 做前缀。我们把最后的排名记作 merged_rank，把 Bangumi 原始排名记作 bangumi_rank，并对每一对排名计算 Kendall Measure，我们得到以下矩阵：</p>
<p><img src="index.png" alt="Kendall Measure Matrix"></p>
<p>如果两个排名的 Kendall Measure 等于 1，说明两个排名的相似度比较大。如果越趋近于 -1，则两个排名完全相反。从这张图我们可以看到，使用 Borda Count 后的综合排名与各大排名的 Kenall Measure 都比 Bangumi 原始平均分排名表现要好，这充分说明了我们排名的科学性。</p>
<p>下表是该综合排名拍出来的 Bangumi 已排名 3252 部动画的前 20 位对应的作品 id：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>rank</th>
</tr>
</thead>
<tbody>
<tr>
<td>253</td>
<td>1</td>
</tr>
<tr>
<td>326</td>
<td>2</td>
</tr>
<tr>
<td>324</td>
<td>3</td>
</tr>
<tr>
<td>265</td>
<td>4</td>
</tr>
<tr>
<td>237</td>
<td>5</td>
</tr>
<tr>
<td>321</td>
<td>6</td>
</tr>
<tr>
<td>6049</td>
<td>7</td>
</tr>
<tr>
<td>1728</td>
<td>8</td>
</tr>
<tr>
<td>110467</td>
<td>9</td>
</tr>
<tr>
<td>2907</td>
<td>10</td>
</tr>
<tr>
<td>340</td>
<td>11</td>
</tr>
<tr>
<td>839</td>
<td>12</td>
</tr>
<tr>
<td>1608</td>
<td>13</td>
</tr>
<tr>
<td>876</td>
<td>14</td>
</tr>
<tr>
<td>3302</td>
<td>15</td>
</tr>
<tr>
<td>238</td>
<td>16</td>
</tr>
<tr>
<td>2734</td>
<td>17</td>
</tr>
<tr>
<td>1428</td>
<td>18</td>
</tr>
<tr>
<td>120700</td>
<td>19</td>
</tr>
<tr>
<td>37460</td>
<td>20</td>
</tr>
</tbody>
</table>
<h2 id="如何在新算法下操纵排名？">如何在新算法下操纵排名？</h2><p>每一种算法都有被攻克的那一天，在提出语义搜索引擎之前，Google 一直在与 SEO 做着猫鼠游戏。当然，我这种简单的排名算法就更容易被操纵了。</p>
<p>如果有用户进行刷分，而且每个小号只为一部作品刷分，那么我的排名算法能够阻止这种作弊行为。但是如果有用户进行刷分的小号对多部作品进行刷分，而且是为某几部作品评高分，而给某几部作品评低分，这样就会对排名算法产生影响。</p>
<p>当然，也存在着针对这种行为的对抗方式，我们只需要对 Keener Rank 进行一些修改就能使得排名不容易被这种作弊方法操纵。</p>
<p>而更为切实际的做法是，将人工排名与计算机排名相融合。在我看来，最为稳定的融合方式是 LeastViolatedMerge，但是这是一个 NPC 问题，目前还没有对 3000 部动画这种规模的 LeastViolatedMerge 解决方案。所以说越科学的排名需要消耗的资源也就越大。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/wattlebird/ranking" target="_blank" rel="external">rankit</a> 是一个使用线性代数和最优化理论为基础的常见排名算法库。这个库是我写的。我说“常见”其实对于绝大]]>
    </summary>
    
      <category term="Machine Learning" scheme="http://wattlebird.github.io/tags/Machine-Learning/"/>
    
      <category term="Projects" scheme="http://wattlebird.github.io/categories/Projects/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[欧拉回路]]></title>
    <link href="http://wattlebird.github.io/2015/06/28/%E6%AC%A7%E6%8B%89%E8%B7%AF/"/>
    <id>http://wattlebird.github.io/2015/06/28/欧拉路/</id>
    <published>2015-06-28T09:16:31.000Z</published>
    <updated>2015-06-28T20:44:14.000Z</updated>
    <content type="html"><![CDATA[<p>今天讨论的主题是一类问题，就是欧拉路问题。有两种欧拉路。第一种叫做 Eulerian path(trail)，沿着这条路径走能够走遍图中每一条边；第二种叫做 Eularian cycle，沿着这条路径走，不仅能走遍图中每一条边，而且起点和终点都是同一个顶点。注意：欧拉路要求每条边只能走一次，但是对顶点经过的次数没有限制。</p>
<p>满足什么性质的图才能有欧拉路？根据 <a href="https://en.wikipedia.org/wiki/Eulerian_path" target="_blank" rel="external">wikipedia</a> 对欧拉路的介绍：</p>
<ul>
<li>在无向图中，所有顶点的度数均为偶，则存在 Eularian cycle；若有且仅有两个顶点的度数为奇，其余的都为偶，则存在 Eularian path；</li>
<li>在有向图中，所有顶点的入度数等于出度数，则存在 Eularian cycle；若有且仅有两个顶点：其中一个入度数比出度数大 1，另一个入度数比出度数小 1，其余的顶点入度数等于出度数，则存在 Eularian path.</li>
</ul>
<p>另外我们还需要知道，对于那些 Eularian path，起点和终点分别在那两个度数为奇的顶点上（对于无向图）或是入度数不等于出度数的顶点上（对于有向图）。</p>
<p>然而知道这些并没有给我们带来多少实惠。因为我们除了判定一个图有没有欧拉路之外，更想找到其中的一条欧拉路径。于是这就是我们今天的重点：寻找欧拉路径的算法。</p>
<p>一个比较经典的算法是 Fleury 算法。Fleury 算法的思想就是：在过河拆桥之前，先想想有没有退路。为什么这么说？Fleury 算法每个回合进行到一个顶点上的时候，都会删除已经走过的边。在选择下一条边的时候，不应该出现这样的状况：在删除下一条边之后，连通图被分割成两个不连通的图。除非没有别的边可选择。该算法从一个奇度数顶点开始（若所有顶点度数均为奇，则任选一个顶点）。当所有的边都走完的时候，该算法结束，欧拉路径为删除路径的顺序。用算法伪代码描述就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v_0 &#60;- a vertex with odd degree or, if no such vertex, any arbitrary vertex.&#10;Repeat:&#10;    select an vertex v_i+1 adjacent of v_i, which should not separate the graph or, the only adjacent vertex of v_i&#10;    remove edge &#60;v_i, v_i+1&#62; and jump to v_i+1&#10;Until all edges have been visited.&#10;Return the sequence of visited edges.</span><br></pre></td></tr></table></figure>
<p>但是该算法的问题就是，怎么判断一条边是否是一个桥呢？如果使用 Tarjan 算法判断，则算法运行时间就是 $O(E^2)$。在实际写代码的时候，我可没考虑那么多。我只考虑，如果在某一点处深搜的结果导致图被分离，那么在某一个边必然走过了一个桥，那么就返回走另一条边。这样的思想形成的算法如下：</p>
<script src="//gist.github.com/12a01616817d8ab33260.js"></script>
<p>粗略分析一下，由于算法要经过每条边，所以时间必然是$\Omega(E)$。在最坏情况下，在每个节点处进行一次 DFS，节点会重复走所以以边计算，所以算法复杂度应该是 $O(E(E+V))$。</p>
<p>另一种计算欧拉路的算法是 Hierholzer 算法。这种算法是基于这样的观察：</p>
<p><img src="14341858378253.png" alt="Hierholzer"></p>
<p>在手动寻找欧拉路的时候，我们从点 4 开始，一笔划到达了点 5，形成路径 4-5-2-3-6-5。此时我们把这条路径去掉，则剩下三条边，2-4-1-2 可以一笔画出。</p>
<p>这两条路径在点 2 有交接处（其实点 4 也是一样的）。那么我们可以在一笔画出红色轨迹到达点 2 的时候，一笔画出黄色轨迹，再回到点 2，把剩下的红色轨迹画完。</p>
<p>由于明显的出栈入栈过程，这个算法可以用 DFS 来描述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DFS(u):&#10;&#9;While (u&#23384;&#22312;&#26410;&#34987;&#21024;&#38500;&#30340;&#36793;e(u,v))&#10;&#9;&#9;&#21024;&#38500;&#36793;e(u,v)&#10;&#9;&#9;DFS(v)&#10;&#9;End&#10;&#9;PathSize &#8592; PathSize + 1&#10;&#9;Path[ PathSize ] &#8592; u</span><br></pre></td></tr></table></figure>
<p>如果想看得更仔细一点，下面是从点 4 开始到点 5 结束的 DFS 过程，其中 + 代表入栈，- 代表出栈。</p>
<p>4+ 5+ 2+ 3+ 6+ 5+ 5- 6- 3- 1+ 4+ 2+ 2- 4- 1- 2- 5- 4-</p>
<p>我们把所有出栈的记录连接起来，得到</p>
<p>5-6-3-2-4-1-2-5-4</p>
<p>诸位看官可以自己再选一条路径尝试一下。不过需要注意的是，起始点的选择和 Fleury 要求的一样。</p>
<p>这个算法明显要比 Fleury 高效，它不用判断每条边是否是一个桥。我写的代码如下：</p>
<script src="//gist.github.com/befdfc0a4802cac3bdfc.js"></script>
<p>需要注意的是这个算法时间复杂度是 $O(E)$。其在 DFS 的过程中不用恢复边，靠出栈记录轨迹。</p>
<p>Fin</p>
<p>（本文大量论述受到 hihocoder week 49, 50 和 51 启发。代码所解决的题目为 <a href="http://hihocoder.com/contest/hiho50/problem/1" target="_blank" rel="external">http://hihocoder.com/contest/hiho50/problem/1</a>）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天讨论的主题是一类问题，就是欧拉路问题。有两种欧拉路。第一种叫做 Eulerian path(trail)，沿着这条路径走能够走遍图中每一条边；第二种叫做 Eularian cycle，沿着这条路径走，不仅能走遍图中每一条边，而且起点和终点都是同一个顶点。注意：欧拉路要求]]>
    </summary>
    
      <category term="Algorithm" scheme="http://wattlebird.github.io/tags/Algorithm/"/>
    
      <category term="C++" scheme="http://wattlebird.github.io/tags/C/"/>
    
      <category term="OJ review" scheme="http://wattlebird.github.io/categories/OJ-review/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[分解质因数]]></title>
    <link href="http://wattlebird.github.io/2015/05/25/%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/"/>
    <id>http://wattlebird.github.io/2015/05/25/分解质因数/</id>
    <published>2015-05-25T08:38:22.000Z</published>
    <updated>2015-05-25T15:39:32.000Z</updated>
    <content type="html"><![CDATA[<p>今天要说的题目来源于 <a href="http://codeforces.com/contest/546/problem/D" target="_blank" rel="external">Soldier and Number Game</a>. 这道题到底干什么呢，说白了就是求两个数$1 \le b \le a \le 5 000 000$之间的所有数的质因数数目之和。快速求解一个数的质因数数目是这道题的关键。</p>
<p><a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="_blank" rel="external">Sieve of Eratosthenes</a> 是这道题的关键。这是一个求解质数/质数判定的方法，其思想是筛选出一个质数的整数倍，质数的整数倍必然不是质数，所以都被筛选出去。在没有筛选的结果中继续求解当前最小数字的整数倍，直至筛完为止。其 C++ 代码如下所示：</p>
<figure class="highlight cpp"><figcaption><span>Sieve of Eratosthenes</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prime number table from 2 to 5000000</span></span><br><span class="line"><span class="comment">// those who have number 0 are prime numbers.</span></span><br><span class="line"><span class="keyword">int</span> table[<span class="number">5000001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_table</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> limit = <span class="built_in">sqrt</span>(<span class="number">5000000</span>)+<span class="number">1</span>;</span><br><span class="line">    table[<span class="number">0</span>]=table[<span class="number">1</span>]=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=limit; i++)</span><br><span class="line">        <span class="keyword">if</span>(!table[i])</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>; j*i&lt;=<span class="number">5000000</span>; j++)</span><br><span class="line">                table[i*j]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isprime</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="keyword">return</span> !table[i];&#125;</span><br></pre></td></tr></table></figure>
<p>你可以发现，在这个质数表中实际上还存储了每个数字的一个质因数。要提取出一个数的完整质因数分解，只要依据<s>基本法</s><code>a/=table[a]</code>不断迭代就可以了。</p>
<p>但是如果按照这样的思路去数每个数的质因数个数的话，在原题中还是会超时。其一个原因是我们要求的是质因数的个数，其可以在建立质数表的时候完成。其二，求从 a 到 b 中每个质因数的个数之和，倾向于使用部分和的方法。</p>
<p>那么怎么求每个数的质因数个数呢，在 Sieve of Eratosthenes 的基础之上？</p>
<figure class="highlight cpp"><figcaption><span>Number of Prime Factors</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_table</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//const int limit = sqrt(5000000)+1;</span></span><br><span class="line">    <span class="comment">//table[0]=table[1]=-1;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=<span class="number">5000000</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(!table[i])</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;=<span class="number">5000000</span>; j+=i)</span><br><span class="line">                table[j]=table[j/i]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天要说的题目来源于 <a href="http://codeforces.com/contest/546/problem/D" target="_blank" rel="external">Soldier and Number Game</a>. 这道题到底干什么呢，说白]]>
    </summary>
    
      <category term="Algorithm" scheme="http://wattlebird.github.io/tags/Algorithm/"/>
    
      <category term="C++" scheme="http://wattlebird.github.io/tags/C/"/>
    
      <category term="OJ review" scheme="http://wattlebird.github.io/categories/OJ-review/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Combination Sum]]></title>
    <link href="http://wattlebird.github.io/2015/04/26/Combination-Sum/"/>
    <id>http://wattlebird.github.io/2015/04/26/Combination-Sum/</id>
    <published>2015-04-26T04:08:44.000Z</published>
    <updated>2015-05-01T19:23:24.000Z</updated>
    <content type="html"><![CDATA[<p>Combination sum <a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="external">1</a> and <a href="https://leetcode.com/problems/combination-sum-ii/" target="_blank" rel="external">2</a> 是 Leetcode 上面两道比较相似的题目。今天写这个题目是因为这个题目有不同的解法。</p>
<p>这两道题目都是给定一组数，给定一个 target，然后求出这组数中哪几个可以组合成 target。不同的地方是，第一道题要求数字可以被重复利用以组合成 target；第二道题要求数字不可以被重复利用。Seems easy, hmm?</p>
<p>首先说说我的想法和做法。首先通过观察可以得知，求一个 target 的 combination 可以被拆分成给定某个已知数的剩下数值的 combination 的子问题。于是乎，可以在确定一个 candidate 的同时试图解决这个子问题，子问题应该返回一个所有解的列表，把该 candidate 加入所有解的尾部即可。</p>
<p>那么怎么选取 candidate 呢？我们可以先对原候选数组进行排序，从最接近 target 的最大数开始筛选 candidate。</p>
<p>但是这里面还有不少问题。在解决子问题的时候，父问题应该传递给子问题这样的信息，使得子问题在选择 candidate 的时候，不应该出现重复的解。比如说在数组<code>[2,3,6,7]</code>，target 为 7 的时候，当目前确定一个 candidate 为 2，子问题就是相同数组中 target 为 5 的问题。但是此时是否能选择 candidate 为 3 呢？这就与 target 为 7 时 candidate 选为 3 的时候相重复了啊。为了力避这种情况，我规定父问题必须传给子问题当前的 candidate，使得子问题在选择 candidate 之时永远小于父问题 candidate。</p>
<p>所以解决问题的代码如下：</p>
<figure class="highlight cpp"><figcaption><span>Combination Sum I</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        sort(candidates.begin(),candidates.end());</span><br><span class="line">        <span class="keyword">return</span> dfs(candidates,target,INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dfs(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> pred)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator itr;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        itr = upper_bound(candidates.begin(), candidates.end(), target);</span><br><span class="line">        <span class="keyword">if</span>(itr==candidates.begin()) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            itr--;</span><br><span class="line">            <span class="keyword">int</span> t = *itr;</span><br><span class="line">            <span class="keyword">if</span>(t&gt;=pred) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(target%t)) ans.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(target/t,t));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=target/t; i++)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vst = dfs(candidates, target-i*t, t);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">size_t</span> j=<span class="number">0</span>; j!=vst.size(); j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k!=i; k++) vst[j].push_back(t);</span><br><span class="line">                copy(vst.begin(), vst.end(), back_inserter(ans));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span>(itr!=candidates.begin());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面第二道题，第一道题之后应该不是什么难题，因为所有的数只能选择一次，所以在选择 candidate 的时候用不着去尝试多次选取的情况了。但是这里还有一个问题：位置不同、但是“看上去”结果相同的解被算作同一个！</p>
<p>为了优雅地解决这个问题，我规定在选取下一个 candidate 的时候，需要跳过与目前 candidate 相同的值。（注意第 22 行）</p>
<p>所以这个问题解决的代码如下：</p>
<figure class="highlight cpp"><figcaption><span>Combination Sum II</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        <span class="keyword">return</span> dfs(candidates.rbegin(),candidates.rend(),target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dfs(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_reverse_iterator b, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_reverse_iterator e,</span><br><span class="line">            <span class="keyword">int</span> target)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_reverse_iterator itr;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        itr = upper_bound(b,e,target,greater_equal&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">if</span>(itr==e) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(itr!=e)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = *itr;</span><br><span class="line">            <span class="keyword">if</span>(t==target) ans.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>,t));</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vs = dfs(++itr, e, target-t);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i!=vs.size(); i++)&#123;</span><br><span class="line">                vs[i].push_back(t);</span><br><span class="line">                ans.push_back(vs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(itr!=e &amp;&amp; *itr==t) itr++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是，以上这些方法都是沿用了 dfs 的思想。既然问题能被拆分为子问题，那么为何不用 DP？这当然是一个正当的思路。</p>
<p>我们记 target 从 0 到 target 的所有解的数组为 dp[target+1]，最终的结果就是要求 dp[target]。显然我们有 dp[target]=vector<int>({itm.push_back(candidate) for itm in dp[target-i]})（抱歉这种不伦不类的语法）</int></p>
<p>但是状态转移方程还没有明确从哪里取得 candidate。其实只要从所有 candidate 里面一个一个抽取出来就可以了。</p>
<p>所以说解决第一题的伪代码如下：</p>
<figure class="highlight plain"><figcaption><span>Combination Sum I in DP</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[0]=vector&#60;vector&#60;int&#62;&#62;()&#10;for c in candidates:&#10;    for j in [c, target]:&#10;        &#22914;dp[j-c]&#38750;&#31354;&#65306;&#10;        dp[j] = &#25226;dp[j-c]&#20013;&#30340;&#27599;&#19968;&#20010;&#35299;&#37117;push_back&#19968;&#20010;c</span><br></pre></td></tr></table></figure>
<p>对于第二题用 DP 的话必须配合 Hash set。</p>
<p>另外，您发现了，用 dp 解的话与背包问题（0-1背包和可重复背包）有什么相似之处吗？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Combination sum <a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="external">1</a> and <a href="https://leetco]]>
    </summary>
    
      <category term="Algorithm" scheme="http://wattlebird.github.io/tags/Algorithm/"/>
    
      <category term="C++" scheme="http://wattlebird.github.io/tags/C/"/>
    
      <category term="OJ Review" scheme="http://wattlebird.github.io/categories/OJ-Review/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[How I build up Chi: 同步率改 v0.3 实现细节]]></title>
    <link href="http://wattlebird.github.io/2015/03/08/How-I-build-up-Chi-%E5%90%8C%E6%AD%A5%E7%8E%87%E6%94%B9-v0-3-%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/"/>
    <id>http://wattlebird.github.io/2015/03/08/How-I-build-up-Chi-同步率改-v0-3-实现细节/</id>
    <published>2015-03-07T17:57:46.000Z</published>
    <updated>2015-05-01T20:42:02.000Z</updated>
    <content type="html"><![CDATA[<p>　　我想我已经好久都没写日志了，因为每天都会学到太多的新东西，虽然想记录下来，但实在是有心无力——太耗时间。不过我想仍然有里程碑意义的成果必须记录下来。这个<a href="http://ikely.me/chi/similarity" target="_blank" rel="external">同步率改 v0.3</a> 就是一个。</p>
<p>　　Bangumi 番组计划有一个可以内置的查看用户间同步率的功能，但是这个功能很简陋，也很不科学。我通过爬取 Bangumi 用户作品收藏信息，计算出了比较科学一点的同步率，使得品味相近的用户可以互相认识。</p>
<p>　　稍有常识的人就会看出，这实际上就是一个推荐系统嘛：推荐与你相似的用户。但是目前的同步率改不能完全算是一个推荐系统，只能说起到了某些推荐系统的功能而已。现在的“同步率改”之所以还保留着“同步率”的称法，是为了让 BGMer 在旧同步率和新同步率之间保持无缝概念接受：如果我没有标注某部作品，那么这部作品不应该在同步率上有所贡献。所以在到目前为止，所有的同步率计算都是在作品空间中进行的而非概念空间。</p>
<p>　　同步率改的 v0.2.1 版是一个比较基本的推荐系统实现：提取用户的所有评分并减去其平均值，得到用户对作品的偏好程度。同时对于用户没有评分的作品，利用这个作品所处于的五个状态——想看、在看、看过、搁置和抛弃——加上一定评分偏置。同时为了防止只有很少评分的用户影响系统表现，系统做了不少 trick，如评分在标准差在零点几以下的用户同步率无视评分、收藏小于 3 的用户无视评分等。这样的设计方法虽然整体思路是正确的，但是存在 ad hoc 太多、评分偏置单一的现象。</p>
<p>　　同时，在 Bangumi 社区交流的过程中，我发现用户对于不同类型的作品评分有一定的独立性。对于动画和三次元的评分准则，有些用户将其与音乐、书籍类作品相独立看待。</p>
<p>　　基于这样的事实，我在 v0.2.1 的基础上进行了大量修改，其结果就是 v0.3。他们一脉相承的特点都是：相似度在作品空间中计算，每位用户的向量都以其自己平均分为基准，对已收藏但未评分作品根据作品收藏状态有一定偏置。但是 v0.3 使用了子空间分解技术估计用户已收藏和未评分作品的评分。同时，不同类型作品的同步率分开计算，最后整合在一起形成综合同步率。</p>
<h2 id="评分估计模型">评分估计模型</h2><p>　　我们记 Bangumi 某一类型（比如动画）作品的 user-item utility matrix 为 $R$，其是一个 $M \times N$ 的矩阵，其中用户数为 $M$，作品数为 $N$。矩阵的元素是元素所在行对应的用户评分减去该用户评分的平均值。用户未评分的元素值记为 0。我们的目的，就是要对某一个用户已标记未评分、收藏状态为 $s$ 的作品进行评分预估：  </p>
<span>$$\begin{equation}
 r_{ij}=u_i v_j^T+bu_{is}+bi_{js}
\end{equation}$$</span><!-- Has MathJax -->
<p>　　其中 $u_{i}$ 是 $M \times Q$ 的 user-concept matirx $U$ 的第 $i$ 行行向量，$v_j$ 是 $Q \times N$ 的 concept-item matrix $V$ 的第 $j$ 列列向量。$bu_{is}$ 是用户状态偏置矩阵 $Bu$ 的元素，$bi_{js}$ 是作品状态偏置矩阵 $Bi$ 的元素。得出评分估计模型的关键就是求出这四个矩阵 $U$、$V$、$Bu$ 和 $Bi$，使得 root mean square error (RMSE)最小，同时又有较好的泛化能力。</p>
<span>$$\begin{equation}
RMSE = \frac{1}{\mbox{total rated item number}}\sum\left(r_{ij}-u_i v_j^T-bu_{is}-bi_{js}\right)^2
\end{equation}$$</span><!-- Has MathJax -->
<p>　　实际上，这个问题就是最小化 RMSE 的最优化问题。假定我们已经有了 $U$、$V$、$Bu$ 和 $Bi$ 的初始估计值，那么我们就可以通过梯度下降的方法估计出使得 RMSE 最小的局部最优解。</p>
<p>　　在 RMSE 的表达式中，total rated item number 是一个固定的常数，$r_{ij}$ 是已经观测到的评分。我们把最优化的目标函数写成如下形式：</p>
<span>$$\begin{equation}
Obj = \sum\left(r_{ij}-u_i v_j^T-bu_{is}-bi_{js}\right)^2+\frac{1}{2\sigma^2}\left(\sum_i||u_i||^2+\sum_j||v_j||^2+\sum_i||bu_i||^2+\sum_j||bi_j||^2\right)
\end{equation}$$</span><!-- Has MathJax -->
<p>　　目标函数的第一项是 RMSE，第二项是为了防止 $U$、$V$、$Bu$ 和 $Bi$ 过大的罚项。此目标函数对于行向量 $u_i$ 的导数为：</p>
<span>$$\begin{equation}
\frac{\partial}{\partial u_i}Obj = -2\sum_j\left(r_{ij}-u_i v_j^T-bu_{is}-bi_{js}\right)v_j+\frac{1}{\sigma^2}u_i
\end{equation}$$</span><!-- Has MathJax -->
<p>　　对于其他项的导数可以一一推得，而且计算也很简单，这里就不赘述。</p>
<p>　　但是目前的问题就是如何求出初始的 $U$、$V$、$Bu$ 和 $Bi$？初始值非常重要，选取一个好的初始值可以得到全局最优解。对于 $U$ 和 $V$，其是 $R$ 的一个近似分解。我们可以用 SVD 求出 $U$ 和 $V$ 的初始值。对于 $Bu$，其是一个 $M \times 5 $的矩阵，其每一行的元素是该用户处于想看、在看、看过、搁置或抛弃作品评分平均值与所有作品评分平均值之间的偏差。$Bi$ 是一个 $N \times 5$ 的矩阵，其每一行元素是该作品在 $R$ 中的不同状态中的评分平均值与 $R$ 中的总平均值之间的偏差。</p>
<h2 id="泛化能力">泛化能力</h2><p>　　我们已经推导出了变量的初始值和梯度。通过不断迭代更新 $U$、$V$、$Bu$ 和 $Bi$ 我们可以得到很低的 RMSE。但是矩阵计算量巨大，我们需要在评分系统预估的表现和现有计算能力中取得折中。到底迭代多少次、学习率为多少时合适？</p>
<p><img src="Anime-iterate.png" alt="Anime iterate"></p>
<p>　　上图是在动画类别中的 RMSE 随迭代次数变化的变化场景。我按照 7:2:1 的比例将所有动画作品评分划分为训练集、验证集和测试集（后来我发现其实这个阶段还不要用测试集）。可以看出，RMSE 在训练集上可以训练到很低，但是更多的迭代次数对验证集的 RMSE 下降作用不大。因此，我选取了在验证集 RMSE 下降曲线的第二个拐点，即迭代次数约为 70 次的位置作为迭代次数。</p>
<p>　　另外一个参数是学习率的选取。根据经验，学习率选取在 0.0002 时为合适。但即使如此，在计算动画类的时候，学习率在 0.0002、罚项 $\sigma^2$ 在 10 的时候还会发散。因此动画类的学习率在迭代 10 次之后，以 0.00002 的学习率继续迭代下降。</p>
<h2 id="余弦距离">余弦距离</h2><p>　　在预估出所有已收藏未评分的作品评分之后，我仍然采用余弦距离计算用户之间的同步率。正如上文所说，这样用户未收藏的作品不会影响同步率。目前阶段，我不想让用户看到某位和他/她同步率很高的人看的是完全不同的动画——尽管它们有相同的概念。</p>
<p>　　在同步率过去的反馈里，我总是听到有人抱怨有收藏了个位数作品的人进入了他们的前十榜单。但是，只要同步率还是采取这样的保守定义：即在作品空间的余弦距离，这种现象永远不会得到根治。</p>
<p>　　设想一下，如果用户 A 看过的作品是你的子集，而用户 B 看过更多的作品，他不仅看过 A 的作品，而且还看过更多的你没看过的其他作品，那么可能谁会更高？这个答案毫无疑问是 A 与你的同步率更高——尽管你可能更想让 B 在你的同步率榜单中靠前一些。也就是说，相同条件下，余弦距离的定义使得系统必然偏向收藏数目少的人。</p>
<p>　　鉴于这样的事实，我想同步率这个玩具，v0.3 就是它最后的一个版本了。如果要以“寻求同好”为目的，就必须抛弃“同步率”这样陈旧的概念。</p>
<h2 id="下一步？">下一步？</h2><p>　　同步率改的设计，我想已经到达了一个里程碑了，而且我想这也完成了我对 matrix factorization 的实践。但是，寻找同好这一终极目标并没有到达。在接下来，对同好的描述可能将不是余弦距离这样直观的模型就能理解的。我已经想好了会怎么做。所以请期待下一个更棒的玩具吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　我想我已经好久都没写日志了，因为每天都会学到太多的新东西，虽然想记录下来，但实在是有心无力——太耗时间。不过我想仍然有里程碑意义的成果必须记录下来。这个<a href="http://ikely.me/chi/similarity" target="_blank" re]]>
    </summary>
    
      <category term="Machine Learning" scheme="http://wattlebird.github.io/tags/Machine-Learning/"/>
    
      <category term="Projects" scheme="http://wattlebird.github.io/categories/Projects/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Misha and Permutations Summation]]></title>
    <link href="http://wattlebird.github.io/2015/01/17/Misha-and-Permutations-Summation/"/>
    <id>http://wattlebird.github.io/2015/01/17/Misha-and-Permutations-Summation/</id>
    <published>2015-01-16T17:01:14.000Z</published>
    <updated>2015-05-01T20:41:54.000Z</updated>
    <content type="html"><![CDATA[<p>　　此题为 CF 上的一道中等难度题。题目的原文见<a href="http://codeforces.com/contest/501/problem/D" target="_blank" rel="external">这里</a>。用中文简单说一下吧：给定0到N-1的两个排列，求这两个排列的“和”。之所以会有“和”的概念出现，是因为排列的大小可以依据字典序确定。</p>
<p>　　所以，解决这个问题需要的两个关键步骤是：根据排列确定字典序大小；根据字典序大小还原排列。</p>
<p>　　一个排列和其字典序大小是有某种确定关系的。<a href="https://en.wikipedia.org/wiki/Factorial_number_system" target="_blank" rel="external">Factorial number system</a> 就这种关系给出了理论支持。这种关系，是一种可以一一对应并且互相转换的关系。比如说，当 N=3 的时候，所有的排列和其字典序大小关系如下所示：</p>
<table>
<thead>
<tr>
<th>排列</th>
<th>字典序大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>012</td>
<td>0</td>
</tr>
<tr>
<td>021</td>
<td>1</td>
</tr>
<tr>
<td>102</td>
<td>2</td>
</tr>
<tr>
<td>120</td>
<td>3</td>
</tr>
<tr>
<td>201</td>
<td>4</td>
</tr>
<tr>
<td>210</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>　　要完成互相转换的任务，必须借助于 factorial number system。这种 system 和通常的十进制、十六进制很相似，只是把“基”换成了数乘。比如说，如何表示 42，利用 factorial number system？ 4! &lt; 42 &lt; 5!</p>
<span>$$\begin{aligned}
42 &amp; =  1 \times 4! + 3 \times 3! + 0 \times 2! + 0 \times 1! + 0 \times 0! \\
　 &amp; =  (((1 \times 4 + 3) \times 3 + 0) \times 2 + 0) \times 1 + 0 \\
　 &amp; =  13000_{!}
\end{aligned}$$</span><!-- Has MathJax -->
<p>　　可以看到，首先 42 小于 5!，因此 42 可以由 5 以下的阶乘表示。<strong>在拆分的时候，每一位的数字不得大于当前位的阶乘数字</strong>。如$13000_{!}$的最高位为 1，1&lt;4。各位看官可以自行拆解几个数字看看。</p>
<p>　　由此，我们可以把第一个表再增加一项，表示出每一个字典序大小的阶乘数系表示：</p>
<table>
<thead>
<tr>
<th>排列</th>
<th>阶乘数系</th>
<th>字典序大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>012</td>
<td>000</td>
<td>0</td>
</tr>
<tr>
<td>021</td>
<td>010</td>
<td>1</td>
</tr>
<tr>
<td>102</td>
<td>100</td>
<td>2</td>
</tr>
<tr>
<td>120</td>
<td>110</td>
<td>3</td>
</tr>
<tr>
<td>201</td>
<td>200</td>
<td>4</td>
</tr>
<tr>
<td>210</td>
<td>210</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>　　那么在阶乘系统下表示出来的数字，好像和排列没有明显的联系啊。好像还不如用原始的方法，就是直接从排列计算出字典序大小呢。那么这一过程怎么计算呢，用最原始的思路？比如说我们现在有排列 120。其第一个数是 1，那么在第一个数是 0 的时候就已经有了 2! 次排列。再看第二位，是 2。在 2 的前面已经有了 0 的排列（这时候就要去掉 1 了），所以其在第一位数为 1 的情况下第二位数为 2 的之前的排列有 1! 个。再看第三位，是0，这时候排序就已经确定了，加上先前的所有排列，就是 2!+1!+1=4。鉴于字典序从 0 开始计数，减去 1 即可。</p>
<p>　　可以看到，在使用原始方法计算字典序的时候，在计算后面的数字的时候要记住前面已经使用了什么数字（看官可以拿一个更大的排列计算一下）。因此，我们如果按照这种思路计算的话，很快就会陷入频繁的大小比较中。</p>
<p>　　如果我们维护一个从 1 到 N 大小的数组，每个数组元素都是 1，并且再维护一个数组，计算其部分和，就会发现，每一次确定某一位之前出现过的数字等于部分和。如果一个数字被用掉了，将其减一，相应的每一位部分和表示该位之前没有被用掉的数字个数。在阶乘系统下表示的数字的每一位，其物理意义就是部分和。我们就此举一个例子：</p>
<p>　　数组为(1,1,1)，部分和为(1,2,3)，排列为120。数组从 1 开始计数，为了方便，排列每一位加 1 变成 231.</p>
<ul>
<li>排列第一位数字 2 索引位置对应的部分和为 2，将其记录下来，并把该位减一. 这时候数组为(1,0,1), 部分和为(1,1,2)；</li>
<li>排列第二位数字 3 索引位置对应的部分和为 2，将其记录下来，并把该位减一. 这时候数组为(1,0,0), 部分和为(1,1,1)；</li>
<li>排列第三位数字 1 索引位置对应的部分和为 1，将其记录下来，并把该位减一。</li>
</ul>
<p>　　我们记录下来的部分和表示了在这样一个排序中，当某一位没有采用该数字的时候可选择的数字个数。由于排列已经确定，我们把记录下来的部分和减一，变成 110。这样，通过部分和，我们就可以很快计算出排列对应的阶乘系统中的数字。看官可以自己拿一个数字计算一下。</p>
<p>　　现在我们解决了<strong>从排列到字典序大小的转换问题</strong>，下面要解决的问题就是<strong>字典序大小到排列的转换</strong>了。如何用传统方法解决？我们可以看到阶乘系统下的数字每一位都有“部分和”的意思。同时排列的每一位数字都是不同的。利用这些信息可以从最高位推出排列。首先阶乘系统下的数字的最高位前面没有被选择的数字，它既是部分和，也是排列中的确定数字。在从排列转化为字典序的过程中，确定的数字被减一，变成不可利用，因此部分和中可以利用的部分和只有第一次出现的某个部分和————因为不可利用的数字其值为 0，在部分和中表示为没有变化。</p>
<p>　　假设我们现在有字典序 2，其对应的阶乘系统数字为 100，我们将其转化为 211。同样地，我们维护数组(1,1,1)和其部分和(1,2,3)。</p>
<ul>
<li>阶乘系统下数字最高位为 2，部分和中第一个出现 2 的索引位置为 2，记录该位置，并将该位置减一，现在部分和为(1,1,2);</li>
<li>阶乘系统下数字次高位为 1，部分和中第一个出现 1 的索引位置为 1，记录该位置，并将该位置减一，现在部分和为(0,0,1)</li>
<li>阶乘系统下数字最低位为 1，部分和中第一个出现 1 的索引位置为 3，记录该位置。</li>
</ul>
<p>　　看官可以发现，之所以记录下来的索引位置是不重复的，是因为每次选取第一个部分和导致了避开使用过的索引位置。记录下来的索引位置为 213，每一位减一等于 102. 看官也可以自己拿一个数字计算一下。</p>
<p>　　那么在实际操作中，怎么计算部分和并更新部分和呢？如果一个位置发生了改变，以后所有的部分和都要发生改变。一个直接的方法就是通过维护线段树，但是更方便的方法是使用<a href="http://baike.baidu.com/view/1420784.htm" target="_blank" rel="external">树状数组</a>。</p>
<p>　　树状数组并不直接管理部分和，而是管理某一段的和。对一个长度为 N+1 的数组，其相对应的树状数组与之等长，并且有以下性质：树状数组索引为 n 处的元素管理着索引区间为 [n-lowbit(n)+1, n] 处原始数组区间之和。所谓 lowbit，是指某一个数转化为二进制后最低非零位置转化为一个 2 的整数次方的值。其为 x &amp; (-x)。总而言之，这个数组有着与 2 的整数次方相关联的树状组织。</p>
<p>　　<img src="tree_array.jpg" alt="Tree Like Array"><br>　　那么要计算部分和，就可以根据这个区间的信息，一块区间一块区间地叠加。可以预见，这样计算部分和的时间复杂度为 O(log n)。</p>
<p>　　那么如何维护树状数组？我们大可以构建一个原始数组然后在其上构建树状数组，但是鉴于这个问题的部分和是按照索引递增的，而且只在原始数组上执行加减一的操作，我们可以直接构建基于树状数组的加减一操作：在包含当前索引处的区间值加减一即可。可以预见，这样维护树状数组的时间复杂度为 O(log n)。</p>
<p>　　到了这里，我想解这道题所需要的所有知识已经明确了。下面是我本人写的代码：</p>
<script src="//gist.github.com/3e6f9a51806662d7fdbf.js"></script>

<p>　　总结：</p>
<ol>
<li>排列与指数系统有着一一对应的关系。排列每个数物理意义为部分和索引，指数系统每一位物理意义为部分和。</li>
<li>树状数组每一个元素试图管理一个 2 的整数次方的大小的长度的数组，lowbit 运算可以实现这一点。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　此题为 CF 上的一道中等难度题。题目的原文见<a href="http://codeforces.com/contest/501/problem/D" target="_blank" rel="external">这里</a>。用中文简单说一下吧：给定0到N-1的两个]]>
    </summary>
    
      <category term="Algorithm" scheme="http://wattlebird.github.io/tags/Algorithm/"/>
    
      <category term="C++" scheme="http://wattlebird.github.io/tags/C/"/>
    
      <category term="OJ Review" scheme="http://wattlebird.github.io/categories/OJ-Review/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OJ 总结(Depricated)]]></title>
    <link href="http://wattlebird.github.io/2015/01/03/OJ-%E6%80%BB%E7%BB%93-Depricated/"/>
    <id>http://wattlebird.github.io/2015/01/03/OJ-总结-Depricated/</id>
    <published>2015-01-02T16:00:00.000Z</published>
    <updated>2015-05-01T21:31:00.000Z</updated>
    <content type="html"><![CDATA[<h3 id="2015-01-04">2015.01.04</h3><p><a href="https://oj.leetcode.com/problems/search-insert-position/" target="_blank" rel="external">Simple Binary Search</a></p>
<p>题目大意就是一种更好的 Binary Search，在一个已经排好序的数组里面找到 target，返回 target 索引。如果找不到，那么就返回 target 应该插入的位置。</p>
<p>我觉得还是 <em>Acclerated C++</em> 那本书给了我很多启示。Binary  search 的搜索区间看作是一个左闭右开区间，每次迭代的过程中，不变的准则是：区间的右边是开区间。这样可以省去考虑中间点恰好是 target 的麻烦。这样做的好处除了省去中间点的考量外，也省略掉了尾端的考虑：在 C 语言中，整数类型向 0 取整，所以 4 是 end 的话，所有小于 4 的数与之相加除以 2 的结果都必然小于 4。</p>
<p>当然这样没考虑区间左端。有一种情况区间左端小于 target，这时候就简单地和等于的情况合并喽。</p>
<p>这道题没用迭代。用迭代还可以再缩短时间。</p>
<p><a href="https://oj.leetcode.com/problems/merge-sorted-array/" target="_blank" rel="external">Merge Sorted Array</a></p>
<p>给定两个已排好序的数组，把它们 merge 成一个。不要再分配空间。</p>
<p>按照惯常的思路是从每个数组的开头开始一一比较然后插入，但这不是 Merge Sort。其实可以从每个数组尾端开始，从大到小插入。但是这样会不会污染原有数据呢？用数学方法证明一下即可。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="2015-01-04">2015.01.04</h3><p><a href="https://oj.leetcode.com/problems/search-insert-position/" target="_blank" rel="external">Simp]]>
    </summary>
    
      <category term="Algorithm" scheme="http://wattlebird.github.io/tags/Algorithm/"/>
    
      <category term="C++" scheme="http://wattlebird.github.io/tags/C/"/>
    
      <category term="OJ Review" scheme="http://wattlebird.github.io/categories/OJ-Review/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Game Theory Note - week 3]]></title>
    <link href="http://wattlebird.github.io/2014/11/01/Game-Theory-Note-week-3/"/>
    <id>http://wattlebird.github.io/2014/11/01/Game-Theory-Note-week-3/</id>
    <published>2014-10-31T16:00:00.000Z</published>
    <updated>2015-05-01T20:21:16.000Z</updated>
    <content type="html"><![CDATA[<p>This week’s material is dedicated to concepts “beyond Nash Equilibrium”: iterative removal of strictly dominated strategies, minimax strategies and the minimax theorem for zero-sum game, correlated equilibria.</p>
<p>Different from previous weeks’ notes, I will illustrate some concepts in Chinese.</p>
<h2 id="Dominated_Strategies">Dominated Strategies</h2><p>Strictly dominated strategies are based on every player’s rationality: that is, everybody is rational, and everybody knows other players make rational decisions, and everybody knows that also… So, those strategies that are strictly dominated are to be dominated. We can get final strategy by using iterated removal.</p>
<h3 id="Example_1:_Prisoner’s_dilemma">Example 1: Prisoner’s dilemma</h3><table>
<thead>
<tr>
<th>Prisoner 1 and 2</th>
<th>Co</th>
<th>Be</th>
</tr>
</thead>
<tbody>
<tr>
<td>Co</td>
<td>-0.5, -0.5</td>
<td>-10, 0</td>
</tr>
<tr>
<td>Be</td>
<td>0, -10</td>
<td>-2, -2</td>
</tr>
</tbody>
</table>
<p>Follow the rational thinking, both prisoners will chose betrayal because choosing betrayal will definitely have him/her spent somewhat less time in prison in comparison to choosing cooperation. In this case, we say that betrayal dominates cooperation.</p>
<p>What’s interesting is that the final strategy, which is a Nash Equilibrium, is not optimal in a overall view. This is where dilemma lies, which illustrates that 非零和博弈中，帕累托最优和纳什均衡是相冲突的.</p>
<h3 id="Example_2:_Intelligent_Pigs">Example 2: Intelligent Pigs</h3><p>The illustration of this game can be found <a href="http://wiki.mbalib.com/wiki/%E4%B8%A5%E6%A0%BC%E5%8A%A3%E5%8A%BF%E7%AD%96%E7%95%A5" target="_blank" rel="external">here</a>.</p>
<table>
<thead>
<tr>
<th>Small pig and big pig</th>
<th>Press</th>
<th>Wait</th>
</tr>
</thead>
<tbody>
<tr>
<td>Press</td>
<td>1,5</td>
<td>-1,9</td>
</tr>
<tr>
<td>Wait</td>
<td>4,4</td>
<td>0,0</td>
</tr>
</tbody>
</table>
<p>In this experiment, we can see that for the small pig, there is a dominate strategy, so the small pig would prefer waiting. After eliminating pressing for small pig, the big pig would chose to press. However, for the big pig, there is no dominate strategy, but after iterative eliminating, (wait, press) becomes the nash equilibrium.</p>
<p>Someone may question about the relationship between Nash equilibrium and dominant strategy equilibrium. 优势策略均衡和纳什均衡的区别在于：在优势策略均衡中，我所做的是不管你做什么，我所能做的是最好的；在纳什均衡中，我所做的是给定你所做的前提下，我所能做的是最好的，你所做的是在给定我所做的前提下你所能做的是最好的，从二者的关系可以看出，优势策略均衡是纳什均衡的一个特例，一个优势策略均衡首先是一个纳什均衡.</p>
<h2 id="Maxmin_Strategies_and_Minmax_Strategies">Maxmin Strategies and Minmax Strategies</h2><p>Maxmin strategy is a strategy that maximizes one’s worst-case payoff. Maxmin Value of the game for player i is that minimum payoff guaranteed by a maxmin strategy. A conservative agent would prefer the maxmin strategy.</p>
<p>Minmax strategy is a strategy that minimizes other’s worst-case payoff.</p>
<p>Theorem<br>: In any finite, two-player, zero-sum game, in any Nash equilibrium each player receives a payoff that is equal to both his maxmin value and his minmax value.</p>
<p>Note: in non-zero-sum game, Nash equilibrium may not equal to maxmin or minmax strategy.<a href="http://wiki.mbalib.com/zh-tw/%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E7%AD%96%E7%95%A5" target="_blank" rel="external">^1</a></p>
<h2 id="Corrleated_Equilibrium">Corrleated Equilibrium</h2><p>Correlated Equilibrium (informal): a randomized assignment of (potentially correlated) action recommendations to agents, such that nobody wants to deviate.</p>
<p>Reference: Correlated equilibrium<a href="https://en.wikipedia.org/wiki/Correlated_equilibrium" target="_blank" rel="external">^2</a>.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>This week’s material is dedicated to concepts “beyond Nash Equilibrium”: iterative removal of strictly dominated strategies, minimax stra]]>
    </summary>
    
      <category term="Coursera" scheme="http://wattlebird.github.io/tags/Coursera/"/>
    
      <category term="Game theory" scheme="http://wattlebird.github.io/tags/Game-theory/"/>
    
      <category term="Notes" scheme="http://wattlebird.github.io/categories/Notes/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Game Theory Note - week 2]]></title>
    <link href="http://wattlebird.github.io/2014/10/18/Game-Theory-Note-week-2/"/>
    <id>http://wattlebird.github.io/2014/10/18/Game-Theory-Note-week-2/</id>
    <published>2014-10-17T16:00:00.000Z</published>
    <updated>2015-05-01T20:21:24.000Z</updated>
    <content type="html"><![CDATA[<p>This week’s Game Theory is dedicated to Mixed-Strategy Nash Equilibrium.</p>
<p>Mixed strategy, different from pure strategy, means that players can choose an action according to a specific probability distribution (among all possible actions). The following concepts and definitions all derives from this idea:</p>
<p>Strategy $s_i$<br>: any probability distribution over the actions $A_i$ for agent i.</p>
<p>Pure strategy<br>: only one action is played with positive probability.</p>
<p>Mixed strategy<br>: more than one action is played with positive probability.</p>
<p>Support (of mixed strategy)<br>: all the actions</p>
<p>We denote $s_i \in S_i$ as $S_i$ is the set of all strategies for user i. All strategies $S = S_1 \times S_2 \times \ldots \times S_n$</p>
<p><strong>Expected Utility</strong> is defined as follows:<br><span>$$\begin{equation}
u_{i}(s) = \sum_{a \in A} u_{i}(a) P(a|s) \
P(a|s) = \prod_{j \in N} s_j(a_j)
\end{equation}$$</span><!-- Has MathJax --><br>In the equations above, a means a possible action profile from A. $a_j$ does not mean each of the action but the player j’s corresponding action in the corresponding profile.</p>
<p>Best response</p>
<p>$s_{i}^{<em>} \in BR(s_{-i}) iff \forall s_i \in S_i u_{i}(s_{i}^{</em>}, s_{-i}) \ge u_{i}(s_i, s_{-i})$</p>
<p>Nash Equilibrium</p>
<p>$s=\<s\_1, s\_2,="" \ldots,="" s\_n="" \=""> \mbox( is a Nash Equilibrium iff }\forall i, s_i \in BR(s_{-i})$</s\_1,></p>
<p>Theorem<br>: Every finite game has a Nash Equilibrium. (While comparing to pure strategy games!)</p>
<p>It is often very hard to compute the Nash Equilibrium of a game, but in simple cases, in which we know the support, we can get the Nash Equilibrium by being acknowledged that a player will act indifferently facing a mixed strategy.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>This week’s Game Theory is dedicated to Mixed-Strategy Nash Equilibrium.</p>
<p>Mixed strategy, different from pure strategy, means that ]]>
    </summary>
    
      <category term="Coursera" scheme="http://wattlebird.github.io/tags/Coursera/"/>
    
      <category term="Game theory" scheme="http://wattlebird.github.io/tags/Game-theory/"/>
    
      <category term="Notes" scheme="http://wattlebird.github.io/categories/Notes/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Game Theory Note - week 1]]></title>
    <link href="http://wattlebird.github.io/2014/10/12/Game-Theory-Note-week-1/"/>
    <id>http://wattlebird.github.io/2014/10/12/Game-Theory-Note-week-1/</id>
    <published>2014-10-11T16:00:00.000Z</published>
    <updated>2015-05-01T20:00:56.000Z</updated>
    <content type="html"><![CDATA[<p>This week’s game theory was dedicated to introduction, overview, uses of game theory, some applications and examples, and formal definitions of: the normal form, payoffs, strategies, pure strategy Nash equilibrium, dominant strategies..</p>
<h2 id="Define_a_Game">Define a Game</h2><ol>
<li>Normal form: List what payoffs get as a function of their actions.</li>
<li>Extensive form: Includes timing of moves, players moves sequentially, represented as a tree.</li>
</ol>
<h3 id="Finite,_n-person_normal_form_game:_$$:">Finite, n-person normal form game: $<n, a,="" u="">$:</n,></h3><ul>
<li>Players: $N={1, \ldots, n}$, indexed by i;</li>
<li>Action set for player i: $a=(a_1, \ldots, a_n) \in A = A_1 \times \ldots \times A_n$ is an action profile;</li>
<li>Utility function or Payoff function for player i: $u_i:A \mapsto \mathbf{R} $, $u=(u_1, \ldots, u_n)$ is a profile of utility functions.</li>
</ul>
<h2 id="Type_of_Games">Type of Games</h2><table>
<thead>
<tr>
<th>Type of Game</th>
<th>Properties</th>
<th>Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pure Competition</td>
<td>1. Exactly two players of opposed interests; Zero sum special case when $u_1(a)+u_2(a)=0$</td>
<td>Matching Pennies, Rock-Paper-Scissors</td>
</tr>
<tr>
<td>Coordination</td>
<td>Players have same interests: $\forall a \in A, \forall i,j, u_i(a)=u_j(a)$</td>
<td>side of road</td>
</tr>
<tr>
<td>Coordination and Competition</td>
<td></td>
<td>Battle of the Sexes</td>
</tr>
</tbody>
</table>
<h2 id="Nash_Equilibrium">Nash Equilibrium</h2><p>In game theory, the Nash equilibrium is a solution concept of a <strong>non-cooperative game</strong> involving two or more players, in which each player is assumed to know the equilibrium strategies of the other players, and no player has anything to gain by changing only their own strategy. If each player has chosen a strategy and no player can benefit by changing strategies while the other players keep theirs unchanged, then the current set of strategy choices and the corresponding payoffs constitute a Nash equilibrium.[^1]</p>
<p>Someone has an incentive to deviate from a profile of actions that do not form an equilibrium.</p>
<p>Best Resopnse<br>: If you knew what everyone else was going to do, it would be easy to pick your own action.<br>: Nash equilibrium looks for stable action profiles.</p>
<h2 id="Dominant_Strategies">Dominant Strategies</h2><p>Strategy (currently) is choosing an action (“pure strategy”)</p>
<p>Denote $s_i$ and $s_i’$ as two strategies for player i, and $S_{-i}$ be the set of all possible strategy profiles for the other players.</p>
<p>$s_i$ strictly dominates $s_i’$ if $ \forall s_{-i} \in S_{-i}, u_{i}(s_i, s_{-i}) \gt u_{i}(s_i’, s_{-i})$<br>$s_i$ very weakly dominates $s_i’$ if $ \forall s_{-i} \in S_{-i}, u_{i}(s_i, s_{-i} ) \ge u_{i}(s_i’, s_{-i})$<br>Please pay attention to the difference between best response, which lies in the definition of strategy.</p>
<p>A strategy profile consisting of dominant strategies for every player must be a Nash equilibrium! An equilibrium in strictly dominant strategies must be unique.</p>
<h2 id="Pareto_Optimality">Pareto Optimality</h2><p>Some times, one outcome $o$ is at least as good for every agent as another outcome $o’$, and there’s some agent who strictly prefers $o$ to $o’$.</p>
<p>An outcome $o^*$ is Pareto-optimal if there is no other outcome that  Pareto-dominates it.</p>
<p>[^1]: Nash equilibrium, <a href="https://en.wikipedia.org/wiki/Real_number" target="_blank" rel="external">https://en.wikipedia.org/wiki/Real_number</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>This week’s game theory was dedicated to introduction, overview, uses of game theory, some applications and examples, and formal definiti]]>
    </summary>
    
      <category term="Coursera" scheme="http://wattlebird.github.io/tags/Coursera/"/>
    
      <category term="Game theory" scheme="http://wattlebird.github.io/tags/Game-theory/"/>
    
      <category term="Notes" scheme="http://wattlebird.github.io/categories/Notes/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一种树的表达法]]></title>
    <link href="http://wattlebird.github.io/2014/10/04/%E4%B8%80%E7%A7%8D%E6%A0%91%E7%9A%84%E8%A1%A8%E8%BE%BE%E6%B3%95/"/>
    <id>http://wattlebird.github.io/2014/10/04/一种树的表达法/</id>
    <published>2014-10-03T16:00:00.000Z</published>
    <updated>2015-05-01T21:28:18.000Z</updated>
    <content type="html"><![CDATA[<p>《算法导论》教导我们，图有两种表达方法：邻接链表和邻接矩阵。至少是对于有环的图来说，的确是这样。对于树和图究竟怎样表达最好，我一直都在摸索之中。以前在写与图有关的算法的时候，总是要把整个邻接链表（通常是一个很大的<code>std::vector&lt;std::list&lt;T&gt;&gt;&amp;</code>）当作参数的一部分送进去。这样看着就很别扭，但是这确实是严格按照《算法导论》的定义实现的。</p>
<p>因此我对我的代码质量深表担忧。但是幸运的是，最近我开始学习起别人的代码，从中获得了一些启示。今天总结的是这么一种特殊的图————自由树的表达方法。这种方法高效，无论是从时间上还是空间上。</p>
<p>假定现在给出一系列树边，每行一条树边记录，由两个数组成。第一个数代表父结点，第二个数代表子结点。这一系列树边可以组成一棵树（或一片森林）。对于这样的信息，利用下面这种方法可以给出高效的表达。</p>
<p>首先我们定义如下结构和数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> prev;</span><br><span class="line">&#125;<span class="keyword">edge_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">edge_t</span> edges[N]; <span class="comment">//边</span></span><br><span class="line"><span class="keyword">int</span> head[N];     <span class="comment">//结点</span></span><br></pre></td></tr></table></figure>
<p>我们知道，在一棵结点数为V的树中，一共有V-1条边。因此给结点和边各开V大小的数组是没问题的。利用这样的数据结构，我们使用如下方法读取边：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for each edge (u,v)</span></span><br><span class="line">edges[i].v=v;</span><br><span class="line">edges[i].prev=head[u];</span><br><span class="line">head[u]=i;</span><br></pre></td></tr></table></figure>
<p>从这段代码中，我们可以看出如下基本事实：</p>
<ol>
<li>edges以边序号为索引，其中v记录的是该边的子结点，prev记录的是另一条边序号；</li>
<li>head以结点序号为索引，其中记录的是边序号；</li>
<li>在第一次涉及到父结点u时，head[u]为0，此时将此值赋给prev，代表空边。在这之后，head[u]被赋予本边序号；</li>
<li>如果再次遇到父结点u，head[u]会被新的边序号覆盖。</li>
<li>因此，head实际上存储着以某个结点为父结点时，其在读取顺序中的最后一条边。如果无子结点，则为0.</li>
</ol>
<p>那么，每个结点最多只存储一条边，如何实现多个子结点的情况？事实上，我们在读到这“最后一条边”时，依照读取顺序的上一条边已经被存储在edges[i].prev中了。按照如下代码，可以方便地完成对某个结点所有子结点的遍历：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=head[i]; k!=<span class="number">0</span>; k=edges[k].prev)&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法适用于：</p>
<ul>
<li>数据以自由树形式表达；</li>
<li>输入数据是边的信息，且标明了父亲孩子关系。</li>
<li>输入边的顺序可以任意。如果要确定根结点，只要再加上一个<code>bool isroot[V]</code>就可以在读取的时候把所有子结点标注出来。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>《算法导论》教导我们，图有两种表达方法：邻接链表和邻接矩阵。至少是对于有环的图来说，的确是这样。对于树和图究竟怎样表达最好，我一直都在摸索之中。以前在写与图有关的算法的时候，总是要把整个邻接链表（通常是一个很大的<code>std::vector&lt;std::list&]]>
    </summary>
    
      <category term="Algorithm" scheme="http://wattlebird.github.io/tags/Algorithm/"/>
    
      <category term="C++" scheme="http://wattlebird.github.io/tags/C/"/>
    
      <category term="Data Structure" scheme="http://wattlebird.github.io/tags/Data-Structure/"/>
    
      <category term="OJ Review" scheme="http://wattlebird.github.io/categories/OJ-Review/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[树的直径]]></title>
    <link href="http://wattlebird.github.io/2014/09/21/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    <id>http://wattlebird.github.io/2014/09/21/树的直径/</id>
    <published>2014-09-20T16:00:00.000Z</published>
    <updated>2015-05-01T21:10:30.000Z</updated>
    <content type="html"><![CDATA[<p>求一个自由树的直径。对于直径，《算法导论》第三版 349 页练习 22.2-8 上面这么定义道：</p>
<blockquote>
<p>树中所有最短路径的最大值即为树的直径。</p>
</blockquote>
<p>这个树由于没有根结点，其实直径这个概念，还是理解为一个连通无向无环图的直径为好。</p>
<p>现在给定如下格式的输入：</p>
<p>8<br>1 2<br>1 3<br>1 4<br>4 5<br>3 6<br>6 7<br>7 8  </p>
<p>第一行是这个图的结点个数，不妨记为 N，以下 N-1 行是 N-1 条边，结点序号按照 1-N 顺序编号。求这个图的直径。</p>
<p>这个输入的输出结果是 6，给出这个示意图就可以看得很清楚：<br><img src="http://media.hihocoder.com/problem_images/20140913/14105773975774.png" alt=""></p>
<p>对于这个问题，最笨的方法就是对每一个结点进行 BFS，因为 BFS 有这个性质：BFS 生成的 广度优先树的每一个结点到达根结点的路径总是最短路。这样，把每一个结点 BFS 一遍就会生成一个该结点到达的最远结点。按照定义取出最长的路径即可。由于 BFS 时间复杂度是 O(N)，这个方法的时间复杂度是$O(N^2)$。</p>
<p>其实还有一个更为简便的方法：首先对任意一个结点做 BFS 求出最远的结点，然后以这个结点为根结点再做 BFS 到达另一个最远结点。第一次 BFS 到达的结点可以证明一定是这个图的直径的一端，第二次 BFS 就会达到另一端。下面来证明这个定理。</p>
<p>但是在证明定义之前，先证明一个引理：</p>
<p><strong>引理</strong>：在一个连通无向无环图中，x、y 和 z 是三个不同的结点。当 x 到 y 的最短路与 y 到 z 的最短路不重合时，x 到 z 的最短路就是这两条最短路的拼接。</p>
<p><strong>证明</strong>：假设 x 到 z 有一条不经过 y 的更短路$\delta (x,z)$，则该路与$\delta (x,y)$、$\delta (y,z)$形成一个环，与前提矛盾。</p>
<p><strong>定理</strong>：在一个连通无向无环图中，以任意结点出发所能到达的最远结点，一定是该图直径的端点之一。</p>
<p><strong>证明</strong>：假设这条直径是$\delta (s,t)$。分两种情况：</p>
<ol>
<li>当出发结点 y 在$\delta (s,t)$时，假设到达的最远结点 z 不是 s,t 中的任一个。这时将$\delta (y,z)$与不与之重合的$\delta (y,s)$拼接（也可以假设不与之重合的是直径的另一个方向），可以得到一条更长的直径，与前提矛盾。</li>
<li><p>当出发结点 y 不在$\delta (s,t)$上时，分两种情况：<br>1). 当 y 到达的最远结点 z 横穿$\delta (s,t)$时，记与之相交的结点为 x。此时有$\delta (y,z)=\delta (y,x)+\delta (x,z)$。而此时$\delta (y,z)&gt;\delta (y,t)$，故可得$\delta (x,z)&gt;\delta (x,t)$。由1的结论可知该假设不成立。<br><img src="/img/tree-illu1.png" alt=""></p>
<p> 2). 当 y 到达的最远结点 z 与$\delta (s,t)$不相交时，记 y 到 t 的最短路首先与$\delta (s,t)$相交的结点是 x。由假设$\delta (y,z)&gt;\delta (y,x)+\delta (x,t)$。而$\delta (y,z)+\delta (y,x)+\delta (x,s)$又可以形成$\delta (z,s)$，而$\delta (z,s)&gt;\delta (x,s)+\delta (x,t)+2\delta (y,x)=\delta (s,t)+2\delta(y,x)$，显然与题意矛盾。<br><img src="/img/tree-illu2.png" alt=""></p>
</li>
</ol>
<p>因此定理成立。</p>
<p><strong>9月21日补充</strong>：这道题是上一周 hihocoder 上面的一道题。出题者的原意并不是要我们这么做。出题者写了很长的一段提示，但是这段提示的语文表述很差，完全没有抓住重点，导致我花了一个星期的时间也没弄明白他在讲什么。现在所有人的源代码均已公开，可以继续下去了。</p>
<p>出题者的原意是要我们使用这么一个定理：</p>
<p><strong>定理2</strong>：树的直径，等于以树直径上任意一点为根的有根树，其左子树的高度+1，再加上其右子树高度+1。</p>
<p>按照这种定理的定义，我们可以设计这样一个程序，对每个结点计算左子树高度+右子树高度+2.这样的时间复杂度是$O(n^2)$。由于我们不知道所选取的结点是否是在直径上，所以要进行这样的枚举。显然这会超时。但是根据<a href="http://www.geeksforgeeks.org/diameter-of-a-binary-tree/" target="_blank" rel="external">本文</a>的提示，寻找这种直径的过程其实可以递归化：</p>
<ol>
<li>在根结点的左子树上；</li>
<li>在根结点的右子树上；</li>
<li>直径经过根结点。</li>
</ol>
<p>于是我们可以设计这样的程序：选取任意结点为根结点，递归地计算每个结点的高度。在结点内部计算高度的同时，计算以当前结点为根的子树的左子树高度+右子树高度+2，用于更新全局树直径。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>求一个自由树的直径。对于直径，《算法导论》第三版 349 页练习 22.2-8 上面这么定义道：</p>
<blockquote>
<p>树中所有最短路径的最大值即为树的直径。</p>
</blockquote>
<p>这个树由于没有根结点，其实直径这个概念，还是理解为一个]]>
    </summary>
    
      <category term="Algorithm" scheme="http://wattlebird.github.io/tags/Algorithm/"/>
    
      <category term="C++" scheme="http://wattlebird.github.io/tags/C/"/>
    
      <category term="Data Structure" scheme="http://wattlebird.github.io/tags/Data-Structure/"/>
    
      <category term="OJ Review" scheme="http://wattlebird.github.io/categories/OJ-Review/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉搜索树与快速排序的内在相似性]]></title>
    <link href="http://wattlebird.github.io/2014/07/27/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%86%85%E5%9C%A8%E7%9B%B8%E4%BC%BC%E6%80%A7/"/>
    <id>http://wattlebird.github.io/2014/07/27/二叉搜索树与快速排序的内在相似性/</id>
    <published>2014-07-26T16:00:00.000Z</published>
    <updated>2015-05-01T21:04:30.000Z</updated>
    <content type="html"><![CDATA[<p>对我来说，对随机事件的分析，恐怕是最难的。我原以为我数学学得还可以，直到我遇上了随机过程。这篇 blog 所讲的是算法分析，其中涉及到大量对随机情况的分析。因此我在此将其梳理一下，特别注重挖掘不同算法之间的分析过程的相似性。</p>
<p>快速排序是一种原址排序方法，随机化的快排具有 <em>O(nlgn)</em> 的期望运行时间。这个在《算法导论》（第三版）的 7.4.2 节中有一个以比较操作为中心的证明方法。这个证明的核心思想就是：快速排序是由多次 partition 过程组成的，因此关键问题就在于获得 partition 过程的运行时间和运行 partition 过程的次数。partition 过程的最大运行次数是 n-1 次，可以记为 <em>O(n)</em> ，对于其运行时间，练习 7.1-3 给出的结论是 <em>Θ(n)</em> 。这样乍一算，似乎是 <em>O($n^2$)</em> 的时间复杂度。这样计算是错误的，因为 partition 的时间复杂度与其长度有关。这里，我们需要更为细致的分析。决定 partition 运行时间的是其内部循环次数。这个循环次数可以统计每次必须运行的比较次数而得到。通过计算整个 quicksort 的比较次数，我们就可以得到真正的 partition 循环次数。而这个比较次数的期望值，可以通过拆分成示性随机变量相加得到。这个分析的精华之处就在于分析出每两个元素进行比较的概率。很有意思，可以进行比较的组合是 <em>Θ($n^2$)</em> ，但是最终全部比较次数的期望是 <em>O(n lgn)</em> 。</p>
<p>当然这个只是作为复习，不是今天的重点。这个方法实在是太不直观了点。这次我们用类似于 merge-sort 的分析方法进行分析。</p>
<h3 id="快速排序分析">快速排序分析</h3><p>按照 merge-sort 的分析思路，quicksort 是将一个问题拆分成了两个子问题，但是由于子问题大小不是固定的，这时候就只能分析运行时间的期望。随机化的快速排序使得任何一个元素成为主元都是等可能的。因此我们有如下式子：</p>
<span>$$\begin{aligned}
E[T(n)] & =  E \left[ \sum^{n}_{q=1} X_q \left( T(q-1) + T(n-q) + \Theta (n) \right) \right] \\
            & =  \frac{2}{n} \sum^{n-1}_{q=2} E[T(q)] + \Theta (n)
\end{aligned}$$</span><!-- Has MathJax -->
<p>随后，可以通过代入法，把 <em>n lgn</em> 代入 T(n)。其中，有如下不等式可以利用：</p>
<span>$$\begin{equation}
\sum^{n-1}_{k=2} k \log k \le \frac{1}{2} n^2 \log n - \frac{1}{8} n^2
\end{equation}$$</span><!-- Has MathJax -->
<p>由于这个不等式的天赐特性，我们只能记住，有如（1）式的结论就是 <em>O(n lgn)</em> 。</p>
<h3 id="二叉搜索树分析">二叉搜索树分析</h3><p>我们知道，二叉搜索树的动态操作时间复杂度是 <em>O(h)</em> 。但是对于随机构建的二叉搜索树来说，其期望树高是 <em>O(n lgn)</em> ，对于随机构建的二叉搜索树来说。这里我们证明的是一个稍弱于此定理的定理：<strong>随机构建的二叉搜索树的平均节点深度为 <em>O(n lgn)</em></strong>。</p>
<p>为表示每一个节点的深度，我们记树<strong><em>T</em></strong>的节点x的深度为 <em>d(x, T)</em> ，而全部节点的深度之和记为 <em>P(T)</em> 。节点平均深度可以表示为</p>
<span>$$\begin{equation}
\frac{1}{n} \sum_{x \in T} d(x, T) = \frac{1}{n} P(T)
\end{equation}$$</span><!-- Has MathJax -->
<p>而每一棵树可以拆分为节点与左子树、右子树。我们需要注意，当把 P(T) 拆分为$P(T<em>{left})$和$P(T</em>{right})$之后深度还应该增加当前树总节点再减一。也就是</p>
<span>$$\begin{equation}
P(T)=P(T_{left})+P(T_{right})+n-1
\end{equation}$$</span><!-- Has MathJax -->
<p>对于某一棵树确实是这样。但是这棵树是随机构建的。如何表示出 P(T) 的期望值？事实上，这里和快速排序一样，在随机构建的过程中，第一个元素总是根节点，每一个元素成为第一个元素的概率都是相等的。因此，我们可以据此写出：</p>
<span>$$\begin{equation}
E[P(n)]=E\left[ \frac{1}{n} \sum_{k=0}^{n-1}(P(k)+P(n-k-1)+n-1)\right]
\end{equation}$$</span><!-- Has MathJax -->
<p>其中 P(n) 是具有 n 个节点的树高。这时候，我们发现，这和在快速排序那里推导出来的式子是非常相似的。因此，延续着快排分析的思路，可以分析出 P(n) = O(n lgn)。</p>
<p>知道这一点有什么用呢？当构建一棵二叉搜索树时，第一个元素会被选为根节点，其后的元素，每一个都要和其比较。这和快速排序的比较次数是一样的。因为当一个元素选为主元的时候，其后的每一个元素都要和其比较。这样，当用相同的序列构建二叉搜索树和进行快速排序的时候，他们所需要的比较次数是相同的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对我来说，对随机事件的分析，恐怕是最难的。我原以为我数学学得还可以，直到我遇上了随机过程。这篇 blog 所讲的是算法分析，其中涉及到大量对随机情况的分析。因此我在此将其梳理一下，特别注重挖掘不同算法之间的分析过程的相似性。</p>
<p>快速排序是一种原址排序方法，随机化]]>
    </summary>
    
      <category term="Algorithm" scheme="http://wattlebird.github.io/tags/Algorithm/"/>
    
      <category term="C++" scheme="http://wattlebird.github.io/tags/C/"/>
    
      <category term="Data Structure" scheme="http://wattlebird.github.io/tags/Data-Structure/"/>
    
      <category term="Analytical" scheme="http://wattlebird.github.io/categories/Analytical/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简单易懂的XML parsing——Qt篇]]></title>
    <link href="http://wattlebird.github.io/2014/05/30/%E7%AE%80%E5%8D%95%E6%98%93%E6%87%82%E7%9A%84XML-parsing%E2%80%94%E2%80%94Qt%E7%AF%87/"/>
    <id>http://wattlebird.github.io/2014/05/30/简单易懂的XML-parsing——Qt篇/</id>
    <published>2014-05-29T16:00:00.000Z</published>
    <updated>2015-05-01T21:22:06.000Z</updated>
    <content type="html"><![CDATA[<p>关于XML的文章我先前写过一篇。之后就再也没写过。原因是很简单的。虽然那篇文章是用Matlab的代码说明XML解析，但是XML的基本概念都是一致的，我也没必要再就C++或是Python等语言再写一遍在其他语言下面怎么用其他的库解析XML，都是大同小异。</p>
<p>可是这个世界上奇葩比较多。最近在做《网络通信原理》的project的时候，用到了Qt里面的QXmlStreamReader。有意思的是，这个东西不按常理出牌。为说明这个特性，我引用Qt 5关于QXmlStreamReader上面的一段话：</p>
<blockquote>
<p>QXmlStreamReader is an incremental parser. It can handle the case where the document can’t be parsed all at once because it arrives in chunks (e.g. from multiple files, or over a network connection).<br>…<br>QXmlStreamReader is memory-conservative by design, since it doesn’t store the entire XML document tree in memory, but only the current token at the time it is reported.</p>
</blockquote>
<p>由这段话我们可以看出，QXmlStreamReader的一个重要特点是，它是一个增量parser。QXmlStreamReader有一个特别的构造函数<code>QXmlStreamReader::QXmlStreamReader(QIODevice * device)</code>，这个device可以是QNetworkReply也可以是QFile。相信这样的好处大家都可以看得出来。为了应付不同IODevice的特性，QXmlStreamReader也只能采取增量解析的方法。然后又有了下面的概念：token.</p>
<p>QXmlStreamReader不在内存中保存全部的DOM tree，现在解析的位置和所解析的对象用token说明。关于什么是token，其实我也不知道。但是QXmlStreamReader提供了一个函数：<code>TokenType QXmlStreamReader::readNext()</code>，有关这个函数的说明是“Reads the next token and returns its type.”</p>
<p>按照官方文档上面的解释，一个可行的解析模型可以是这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QXmlStreamReader xml;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span> (!xml.atEnd()) &#123;</span><br><span class="line">      xml.readNext();</span><br><span class="line">      ... <span class="comment">// do processing</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (xml.hasError()) &#123;</span><br><span class="line">      ... <span class="comment">// do error handling</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，QXmlStreamReader在解析xml的时候，以token为单位解析xml文档数据。</p>
<p>我在上一篇文章中讲过，xml有Element node，Element node以Text node作为child，Attribute node从属于Element node，comment node相对独立，而以上四种node都由document node生成，document node可以说是一个xml文档的代表，xml parsing的核心是element node。但是在Qt中，token与这种标准的概念似乎完全无关。它更关心我现在读到的东西是什么。在TokenType的定义中，一共给出了9种不同token的定义，而判断当前parser的tokenType是什么的函数一共有十二种。</p>
<p>我们可以想象，这种parser，一块一块地读取xml文档，只前进不后退，每一块代表一种既定的token，直到全部读完xml为止（也就是<code>atEnd()</code>为真的时候）。</p>
<p>下面让我展示一段我这个project中的一段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(reply-&gt;error()==QNetworkReply::NoError)&#123;</span><br><span class="line">    ui-&gt;listWidget-&gt;clear();</span><br><span class="line">    articlelist.clear();</span><br><span class="line">    <span class="function">QXmlStreamReader <span class="title">xml</span><span class="params">(reply)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(xml.readNextStartElement() &amp;&amp; xml.name()==<span class="string">"articles"</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(xml.readNextStartElement() &amp;&amp; xml.name()==<span class="string">"article"</span>)&#123;</span><br><span class="line">            Article record;</span><br><span class="line">            <span class="keyword">while</span>(xml.readNextStartElement())&#123;</span><br><span class="line">                <span class="keyword">if</span>(xml.name()==<span class="string">"author"</span>)&#123;</span><br><span class="line">                    record.author = xml.readElementText();</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(xml.name()==<span class="string">"date"</span>)&#123;</span><br><span class="line">                    record.date = xml.readElementText();</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(xml.name()==<span class="string">"title"</span>)&#123;</span><br><span class="line">                    QString t = xml.readElementText();</span><br><span class="line">                    ui-&gt;listWidget-&gt;addItem(t);</span><br><span class="line">                    record.title = t;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(xml.name()==<span class="string">"content"</span>)&#123;</span><br><span class="line">                    record.content = xml.readElementText();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            articlelist.push_back(record);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>xml文档格式如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">articles</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">author</span>&gt;</span>...<span class="tag">&lt;/<span class="title">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">date</span>&gt;</span>...<span class="tag">&lt;/<span class="title">date</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>...<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">content</span>&gt;</span>...<span class="tag">&lt;/<span class="title">content</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">article</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;/<span class="title">article</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="title">articles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>代码中reply是个API请求的回应，我的目的是吧这个回应中的每一条信息存放在articlelist中。值得注意的是14-16行那段代码，由于这个是一个增量parser，我们不能使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;listWidget-&gt;addItem(xml.readElementText());</span><br><span class="line">record.title = xml.readElementText();</span><br></pre></td></tr></table></figure>
<p>否则<code>record.title</code>将为空。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于XML的文章我先前写过一篇。之后就再也没写过。原因是很简单的。虽然那篇文章是用Matlab的代码说明XML解析，但是XML的基本概念都是一致的，我也没必要再就C++或是Python等语言再写一遍在其他语言下面怎么用其他的库解析XML，都是大同小异。</p>
<p>可是这]]>
    </summary>
    
      <category term="C++" scheme="http://wattlebird.github.io/tags/C/"/>
    
      <category term="xml" scheme="http://wattlebird.github.io/tags/xml/"/>
    
      <category term="Notes" scheme="http://wattlebird.github.io/categories/Notes/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简单易懂的XML parsing]]></title>
    <link href="http://wattlebird.github.io/2014/03/11/%E7%AE%80%E5%8D%95%E6%98%93%E6%87%82%E7%9A%84XML-parsing/"/>
    <id>http://wattlebird.github.io/2014/03/11/简单易懂的XML-parsing/</id>
    <published>2014-03-10T16:00:00.000Z</published>
    <updated>2015-05-01T21:18:14.000Z</updated>
    <content type="html"><![CDATA[<p>读取一个XML文件，返回一个DOM对象。</p>
<p>什么是DOM对象？全称为Document Object Model, XML文件中的每一个东西都对应为一个node。DOM node的属性和方法遵循国际互联网的标准。</p>
<p>有以下类型的nodes：</p>
<ul>
<li>Element nodes*   Text nodes 每一个Text node都是Element node的child</li>
<li>Attribute nodes 不是任何node的parent 或 child,从属于element node</li>
<li>Comment nodes*   Document nodes 只有使用document node的方法才能创造新element, text, attribute, comment</li>
</ul>
<p>现有以下xml文档：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">listitem</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">label</span>&gt;</span>Import Wizard<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">callback</span>&gt;</span>uiimport<span class="tag">&lt;/<span class="title">callback</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">icon</span>&gt;</span>ApplicationIcon.GENERIC_GUI<span class="tag">&lt;/<span class="title">icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">listitem</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">listitem</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="title">listitem</span>&gt;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>其中的一个label标签有字符Plot Tools。假设你想在同样的listitem里面寻找callback标签的字符：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">findLabel = <span class="string">'Plot Tools'</span>;</span><br><span class="line">findCbk = <span class="string">''</span>;</span><br><span class="line">xDoc = xmlread(fullfile(matlabroot, ...</span><br><span class="line">               <span class="string">'toolbox'</span>,<span class="string">'matlab'</span>,<span class="string">'general'</span>,<span class="string">'info.xml'</span>));</span><br><span class="line">allListitems = xDoc.getElementsByTagName(<span class="string">'listitem'</span>);</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">0</span>:allListitems.getLength-<span class="number">1</span></span><br><span class="line">    thisListitem = allListitems.item(k);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% Get the label element. In this file, each</span></span><br><span class="line">    <span class="comment">% listitem contains only one label.</span></span><br><span class="line">    thisList = thisListitem.getElementsByTagName(<span class="string">'label'</span>);</span><br><span class="line">    thisElement = thisList.item(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">% Check whether this is the label you want.</span></span><br><span class="line">    <span class="comment">% The text is in the first child node.</span></span><br><span class="line">    <span class="keyword">if</span> strcmp(thisElement.getFirstChild.getData, findLabel)</span><br><span class="line">        thisList = thisListitem.getElementsByTagName(<span class="string">'callback'</span>);</span><br><span class="line">        thisElement = thisList.item(<span class="number">0</span>);</span><br><span class="line">        findCbk = char(thisElement.getFirstChild.getData);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ~<span class="built_in">isempty</span>(findCbk)</span><br><span class="line">    msg = sprintf(<span class="string">'Item "%s" has a callback of "%s."'</span>,...</span><br><span class="line">                      findLabel, findCbk);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   msg = sprintf(<span class="string">'Did not find the "%s" item.'</span>, findLabel);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(msg);</span><br></pre></td></tr></table></figure>
<p>MATLAB本身就提供一个xmlread函数，其返回的是Document Node。根节点哦。其余与Document Node的函数都是标准已经定义了的，这个标准详情请见<a href="http://download.oracle.com/javase/6/docs/api/" target="_blank" rel="external">这里</a>.在上面一段代码中，我们可以看见几个常用的API：</p>
<ul>
<li><code>getElementsByTagName</code>是Document Node的方法，返回一个list。</li>
<li>这个list是node的列表，要得到其中一个元素，需要调用list的<code>item</code>方法。</li>
<li>一个有child的element node，获得其内容，要调用<code>getFirstChild.getData</code>。</li>
</ul>
<p>如果我们想写一个XML文档：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">toc</span> <span class="attribute">version</span>=<span class="value">"2.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">tocitem</span> <span class="attribute">target</span>=<span class="value">"upslope_product_page.html"</span>&gt;</span>Upslope Area Toolbox<span class="comment">&lt;!-- Functions --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">tocitem</span> <span class="attribute">target</span>=<span class="value">"demFlow_help.html"</span>&gt;</span>demFlow<span class="tag">&lt;/<span class="title">tocitem</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">tocitem</span> <span class="attribute">target</span>=<span class="value">"facetFlow_help.html"</span>&gt;</span>facetFlow<span class="tag">&lt;/<span class="title">tocitem</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">tocitem</span> <span class="attribute">target</span>=<span class="value">"flowMatrix_help.html"</span>&gt;</span>flowMatrix<span class="tag">&lt;/<span class="title">tocitem</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">tocitem</span> <span class="attribute">target</span>=<span class="value">"pixelFlow_help.html"</span>&gt;</span>pixelFlow<span class="tag">&lt;/<span class="title">tocitem</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">tocitem</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">toc</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>MATLAB代码如下：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">docNode = com.mathworks.xml.XMLUtils.createDocument(<span class="string">'toc'</span>);</span><br><span class="line"></span><br><span class="line">toc = docNode.getDocumentElement;</span><br><span class="line">toc.setAttribute(<span class="string">'version'</span>,<span class="string">'2.0'</span>);</span><br><span class="line"></span><br><span class="line">product = docNode.createElement(<span class="string">'tocitem'</span>);</span><br><span class="line">product.setAttribute(<span class="string">'target'</span>,<span class="string">'upslope_product_page.html'</span>);</span><br><span class="line">product.appendChild(docNode.createTextNode(<span class="string">'Upslope Area Toolbox'</span>));</span><br><span class="line">toc.appendChild(product)</span><br><span class="line"></span><br><span class="line">product.appendChild(docNode.createComment(<span class="string">' Functions '</span>));</span><br><span class="line"></span><br><span class="line">functions = <span class="cell">&#123;<span class="string">'demFlow'</span>,<span class="string">'facetFlow'</span>,<span class="string">'flowMatrix'</span>,<span class="string">'pixelFlow'</span>&#125;</span>;</span><br><span class="line"><span class="keyword">for</span> idx = <span class="number">1</span>:<span class="built_in">numel</span>(functions)</span><br><span class="line">    curr_node = docNode.createElement(<span class="string">'tocitem'</span>);</span><br><span class="line"></span><br><span class="line">    curr_file = <span class="matrix">[functions&#123;idx&#125; <span class="string">'_help.html'</span>]</span>;</span><br><span class="line">    curr_node.setAttribute(<span class="string">'target'</span>,curr_file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% Child text is the function name.</span></span><br><span class="line">    curr_node.appendChild(docNode.createTextNode(functions<span class="cell">&#123;idx&#125;</span>));</span><br><span class="line">    product.appendChild(curr_node);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">xmlwrite(<span class="string">'info.xml'</span>,docNode);</span><br><span class="line">type(<span class="string">'info.xml'</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>这个函数首先先创建出一个Document Node，也就是最重要的根节点；</li>
<li><code>SetAttribute</code>是Element Node的方法；</li>
<li>element, text, attribute, comment只能由docNode创建，方法是<code>createXXXNode</code>；</li>
<li>Element Node间的父子关系由<code>appendChild</code>确定。</li>
</ul>
<p>以上就是MATLAB里面处理XML文档的最基本知识。由于XML文档的处理方式是统一的，因此很容易就能拓展到其他语言。从代码中就可以挖掘出许多东西。在实际中，要使用到的XML API恐怕还远远不够。这篇文章只是作为一个入门性质的导引。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>读取一个XML文件，返回一个DOM对象。</p>
<p>什么是DOM对象？全称为Document Object Model, XML文件中的每一个东西都对应为一个node。DOM node的属性和方法遵循国际互联网的标准。</p>
<p>有以下类型的nodes：</p>
<]]>
    </summary>
    
      <category term="matlab" scheme="http://wattlebird.github.io/tags/matlab/"/>
    
      <category term="xml" scheme="http://wattlebird.github.io/tags/xml/"/>
    
      <category term="Notes" scheme="http://wattlebird.github.io/categories/Notes/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简单易懂的Sublime Text 2]]></title>
    <link href="http://wattlebird.github.io/2014/02/04/%E7%AE%80%E5%8D%95%E6%98%93%E6%87%82%E7%9A%84Sublime-Text-2/"/>
    <id>http://wattlebird.github.io/2014/02/04/简单易懂的Sublime-Text-2/</id>
    <published>2014-02-03T16:00:00.000Z</published>
    <updated>2015-05-01T21:26:44.000Z</updated>
    <content type="html"><![CDATA[<p>由于这几天一看见Python自带的IDLE我就作呕，我觉得很有必要花点时间研究一下<a href="http://www.sublimetext.com/" target="_blank" rel="external">Sublime Text 2</a>。</p>
<p>为什么要用Sublime Text 2？其实我也不知道。我第一次知道这个编辑器是在Azure的培训上。后来我发现，许多专业人士都非常推崇此编辑器。Sublime Text 2在Windows、Mac和Linux下都有相应的版本。</p>
<p>如果你去看Sublime Text 2的主页，你会发现这个编辑器的最大优点就是多光标编辑。没有其他任何一个编辑器能做到这一点。</p>
<p>下面，我把Sublime的文档简要翻译了一下，权作参考。如果没有特殊说明，下面都是在Windows平台下操作。</p>
<h2 id="大规模行选择">大规模行选择</h2><p><img src="!--￼0--&gt;/img/column-select.png" alt="multiple line selecting"><br>方法一：Shift+右键拖动，或按下中键拖动。<br>如果要额外添加一行光标，使用Ctrl+左键选择。（虽然文档上说Alt是撤销一行光标，但是我从来都没试成功过）<br>方法二：使用键盘：Ctrl+Alt+Up向上选择，Ctrl+Alt+Down向下选择。</p>
<h2 id="多重选择">多重选择</h2><h3 id="选择块区域并分裂成多行">选择块区域并分裂成多行</h3><p>选择一个块区域，然后按下Ctrl+Shift+L，可把一整块的选择区域分成每一行一块的选择区。</p>
<h3 id="快速添加下一相同区域">快速添加下一相同区域</h3><p>我们在文字编辑器里会有相同的变量名，如果我们的光标在其中一个变量名之上，按下Ctrl+D，整个变量名就会被选择。<br>如果再按下Ctrl+D，下一个相同的变量名也会被选择。<br><img src="!--￼1--&gt;/img/multiple-selection.png" alt="multiple block selecting"></p>
<h3 id="一起选定所有相同区域">一起选定所有相同区域</h3><p>光标在变量名上，按下Alt+F3</p>
<h3 id="退回到单个选择模式">退回到单个选择模式</h3><p>按下Esc</p>
<h2 id="自动补全">自动补全</h2><p>自动补全是自动开启的，设置在Preferences/Settings-Default里面，有个”auto_complete”。<br>如果当前弹出窗没有弹出，可以按下Ctrl+空格，强制显示当前可补全选项。不会引发输入法吗，我想。<br>在HTML文档里，’&lt;’键是触发自动补全的按键。</p>
<h2 id="Tab补全">Tab补全</h2><p>Tab补全是自动开启的，有个”tab_completion”的选项。<br>如果当前的补全结果并非为我所愿，可以按下Ctrl+空格，显示补全选框。<br>如果按下Tab不想补全而是写下制表符，可以按下Shift+Tab。</p>
<h2 id="不受干扰模式">不受干扰模式</h2><p>这种模式跟全屏模式还有些区别。<br>View/Enter Distraction Free Mode打开此模式。或直接按Shift+F11。<br>设置不受干扰模式：与上文不同，路径在_Preferences/Settings - More</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  &#10;    &#34;line_numbers&#34;: false,  &#10;    &#34;gutter&#34;: false,  &#10;    &#34;draw_centered&#34;: true,  &#10;    &#34;wrap_width&#34;: 80,  &#10;    &#34;word_wrap&#34;: true,  &#10;    &#34;scroll_past_end&#34;: true  &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个设置样本。特别注意的是”wrap_width”这个选项，这个选项之大小决定了该模式下的编辑宽度。</p>
<h2 id="Vintage_Mode">Vintage Mode</h2><p>这个是Vi模式。此模式在默认状态下是关闭的，你需要做的是将其从ignored-packages中去除。编辑<code>&quot;ignored_packages&quot;: [&quot;Vintage&quot;]</code>至<code>&quot;ignored_packages&quot;: []</code>即可。</p>
<p>Vintage模式默认状态是insert mode。如有不适请添加如下一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#34;vintage_start_in_command_mode&#34;: true</span><br></pre></td></tr></table></figure>
<p>需要注意的是，Vintage模式下的insert模式是Sublime正常工作的模式，在此情况下的vi快捷键不可用。而且Ex模式也不可用。</p>
<p>Ctrl快捷键与Sublime冲突，默认关闭。如需启用，请打开</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#34;vintage_ctrl_keys&#34;: true</span><br></pre></td></tr></table></figure>
<h2 id="Projects">Projects</h2><p>在Sublime Text 2中，Projects由两个文件组成：</p>
<ul>
<li>Sublime Project File：定义Project，需要加入版本控制；*   Sublime-workspace file：用户的数据。</li>
</ul>
<p>Sublime-Project File是一个JSON文件，顶层分三大部分：Folders明确包含的文件，Settings会覆写用户设置，还有Build_systems。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>由于这几天一看见Python自带的IDLE我就作呕，我觉得很有必要花点时间研究一下<a href="http://www.sublimetext.com/" target="_blank" rel="external">Sublime Text 2</a>。</p>
<p>]]>
    </summary>
    
      <category term="sublime text 2" scheme="http://wattlebird.github.io/tags/sublime-text-2/"/>
    
      <category term="tools" scheme="http://wattlebird.github.io/tags/tools/"/>
    
      <category term="Notes" scheme="http://wattlebird.github.io/categories/Notes/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[坡道的起点——AWS上Wordpress建站小记]]></title>
    <link href="http://wattlebird.github.io/2014/01/26/%E5%9D%A1%E9%81%93%E7%9A%84%E8%B5%B7%E7%82%B9%E2%80%94%E2%80%94AWS%E4%B8%8AWordpress%E5%BB%BA%E7%AB%99%E5%B0%8F%E8%AE%B0/"/>
    <id>http://wattlebird.github.io/2014/01/26/坡道的起点——AWS上Wordpress建站小记/</id>
    <published>2014-01-25T16:00:00.000Z</published>
    <updated>2015-05-01T21:09:46.000Z</updated>
    <content type="html"><![CDATA[<p>经过若干天的反复瞎搞，这个名为”Pursuing Freedom”的博客终于上线了。</p>
<p>建立一个个人博客本来不是难事，只要你肯花钱。国内国外本来就有很多主机提供商，而且有些还是提供注册域名、服务器搭建的一条龙服务。但是Ike酱认为，有钱首先应该花在手办上，其他的能省就省～上个学期接受了一个Azure的培训，从那个培训中Ike酱得知现在云服务可以做很多事情。而且亚马逊的AWS在一定的使用范围内是免费的，这就提供了无限多的可能构造一个自由定制的主页。下面Ike将会把这次建站的各个方面记录一下，供以后参考。</p>
<p>首先我们从AWS讲起。AWS全称Amazon Web Services。和Windows Azure一样，AWS提供了一系列云解决方案。在注册AWS用户的一年时间之内，可以在限定的范围内，免费使用AWS的部分服务。有关这些详情，请参考<a href="http://docs.aws.amazon.com/gettingstarted/latest/awsgsg-intro/gsg-aws-free-tier.html" target="_blank" rel="external">How Do I Get Started with the Free Usage Tier?</a>。</p>
<p>有必要强调一点的是，注册AWS的账号需要一张国际信用卡。对于弊校学生来说，这还是一件比较容易办得到的事情，因为Ike常常见到食堂附近有建行的人在接受集体办卡。（Ike能说Ike拿到这个信用卡之后的第一件事就是开通了AWS账号么）</p>
<p>建站的过程其实很简单，因为AWS的Documention上已经把步骤都写好了。概要地说，就是使用AWS EC2建立一台虚拟机，进行安全和账户控制，然后在这个虚拟机上安装各式各样的东西～怎样建立一个虚拟机的Instance，怎样通过远程终端连接上去，怎样配置Apache+PHP+MySQL，其实我不是Linux的专家，但是<a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/" target="_blank" rel="external">Amazon EC2 User Guide</a>上面都说得一清二楚。别看文档有600页，其实建立个人博客只要前几页就够了。</p>
<p>在这里整理一下，我参考文档的顺序是：<br>1. <a href="http://docs.aws.amazon.com/gettingstarted/latest/awsgsg-intro" target="_blank" rel="external">Getting Started with AWS</a><br>2. <a href="http://docs.aws.amazon.com/gettingstarted/latest/awsgsg-freetier/" target="_blank" rel="external">Getting Started with AWS Free Usage Tier</a><br>3. <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/" target="_blank" rel="external">Amazon EC2 User Guide</a><br>我并不想把这里面的内容再抄一遍放在这里来，说实在的，这一建站步骤唾手可得。</p>
<p>在完成wordpress博客的创建之前，如果有任何问题，都可以归结到文档步骤没有仔细遵循的原因上。总体而言，建立wordpress博客的步骤要比Windows Azure复杂，但是也可以说Windows Azure忽略了许多重要的东西。</p>
<p>但是，在建立了这个wordpress博客、并可以访问之后，是否说明真的可以用了呢？其实后续还有许多复杂的事情要做。</p>
<p>首先就是虚拟机的权限设置问题。在EC2 UG里面，我们给虚拟机创建了一个名为www的group，理由是可以让ec2-user获得对/var/www/的修改权限。但是在实际中，光给ec2-user一个用户这些权限还不够。Wordpress程序可以进行插件的自动安装和自动更新，如果apache拿不到这些权限，Wordpress的更新和拓展都很麻烦。理论上说我们可以每次都登录虚拟机用ec2-user做这些事情，但这样大大提高了博客的使用门槛。</p>
<p>其次，在UG里面没有提到ftp的设置。ftp会给个人网站的部署和更新带来很大便利。wordpress进行更新也需要用到ftp。</p>
<p>关于这两个问题，我给ftp的user和服务器apache都加入到用户组www中，确认网站的根目录下对www都有读写权限。关于ftp的部署，我主要参考了<a href="http://www.chilltouch.com/2013/06/aws-ec2-ftp" target="_blank" rel="external">AWS EC2上架设 FTP</a>。</p>
<p>但是真正麻烦的，是Wordpress服务器经常连接不上数据库的问题。虽然wp-config.php里面的参数都配置正确，但就是无法连接。这个博客其实是第三代博客，就是因为这个问题。一种可能的解决方案是重启虚拟机，但是发现有时候不可行。这个问题Ike参考了许多中外网站，总的来说都不适用。博客所维持时间的长短几乎就取决于什么时候出现这个数据库的问题。</p>
<p>Ike对Linux只是略知皮毛，连鸟哥私房菜第一卷都没看完的战五渣，上面这些问题的解决真的是瞎搞，所以要是把详细的步骤写出来反而有误人子弟之嫌。所以说，建立了这个博客只是站在长长的坡道的起点，以后还要建设邮件系统之类的东西，还要有个像模像样的主页面，但在当前看来最重要的是把MySQL学会。</p>
<p>域名的注册是在Godaddy上注册的，原来想用ikely.cc以暗示真名，或是ike.ly，但是.me的域名实在是便宜，10刀一年。域名前面原来有www，要去掉www很简单，只要在Godaddy的域名转发里面设置子域名转发就可以了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>经过若干天的反复瞎搞，这个名为”Pursuing Freedom”的博客终于上线了。</p>
<p>建立一个个人博客本来不是难事，只要你肯花钱。国内国外本来就有很多主机提供商，而且有些还是提供注册域名、服务器搭建的一条龙服务。但是Ike酱认为，有钱首先应该花在手办上，其他的]]>
    </summary>
    
      <category term="Backend" scheme="http://wattlebird.github.io/tags/Backend/"/>
    
      <category term="apache" scheme="http://wattlebird.github.io/tags/apache/"/>
    
      <category term="wordpress" scheme="http://wattlebird.github.io/tags/wordpress/"/>
    
      <category term="Projects" scheme="http://wattlebird.github.io/categories/Projects/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Permalink 404 Error 之解决方案]]></title>
    <link href="http://wattlebird.github.io/2014/01/26/Permalink-404-Error-%E4%B9%8B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://wattlebird.github.io/2014/01/26/Permalink-404-Error-之解决方案/</id>
    <published>2014-01-25T16:00:00.000Z</published>
    <updated>2015-05-01T20:55:18.000Z</updated>
    <content type="html"><![CDATA[<p>Ike本人在设置wordpress的时候，在settings里面发现了Permalink。从这个页面的主要介绍来看，Permalink的作用就是自定义文章的Link，使之更为结构化和友好。</p>
<p>但是当Ike设置了某个除Default之外的某个Permalink的时候，如果点击一篇发表的文章，就会出现Page Not Found的404错误。</p>
<p>经反复查证，Ike发现Permalink与.htaccess和Apache的设置紧密相关。</p>
<p>如果我们在Settings页面的Permalink中就某个选项进行了保存，wordpress在后台就会改写.htaccess：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># BEGIN WordPress&#10;&#60;IfModule mod_rewrite.c&#62;&#10;RewriteEngine On&#10;RewriteBase /blog/&#10;RewriteRule ^index\.php$ - [L]&#10;RewriteCond %&#123;REQUEST_FILENAME&#125; !-f&#10;RewriteCond %&#123;REQUEST_FILENAME&#125; !-d&#10;RewriteRule . /blog/index.php [L]&#10;&#60;/IfModule&#62;&#10;# END WordPress</span><br></pre></td></tr></table></figure>
<p>这个.htaccess文件是存放在网页的根目录下的，和wp-config.php存放的位置一样。如果wordpress不能改写此文件，则需要手动改写，但需要注意到的是Ike本人的网页是放在/blog文件夹下的，如果放在别的文件夹下，正确的.htaccess内容可能和上面不一样。</p>
<p>如果成功改写.htaccess，只是成功了一半。因为Ike本人发现即使赋予了后台改写.htaccess的权限，还是不能访问。</p>
<p>有文献报道指出，Apache需要使能rewrite_module才能使得Permalink正常工作。这就需要改写Aapche的配置文件。</p>
<p>运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find / -type f -iname &#34;httpd.conf&#34;</span><br></pre></td></tr></table></figure>
<p>找到Apache的配置文件的位置。据相关文献报道，需要做的是将</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#LoadModule rewrite_module modules/mod_rewrite.so</span><br></pre></td></tr></table></figure>
<p>的注释去掉。</p>
<p>但甚为坑爹的是，Ike发现虚拟机上的Apache配置文件本来就没有把这一行给注释掉。</p>
<p>经过一番查证，这里一篇<a href="https://stackoverflow.com/questions/17206524/404-error-after-changing-permalinks-wordpress" target="_blank" rel="external">帖子</a>为我们给出了解决方案的暗示。于是Ike在配置文件下找到了如下若干行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#10;# Each directory to which Apache has access can be configured with respect&#10;# to which services and features are allowed and/or disabled in that&#10;# directory (and its subdirectories).&#10;#&#10;# First, we configure the &#34;default&#34; to be a very restrictive set of&#10;# features.&#10;#&#10;&#60;Directory /&#62;&#10;    Options FollowSymLinks&#10;    AllowOverride All&#10;&#60;/Directory&#62;&#10;&#10;...&#10;&#10;#&#10;# Possible values for the Options directive are &#34;None&#34;, &#34;All&#34;,&#10;# or any combination of:&#10;#   Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews&#10;#&#10;# Note that &#34;MultiViews&#34; must be named *explicitly* --- &#34;Options All&#34;&#10;# doesn&#39;t give it to you.&#10;#&#10;# The Options directive is both complicated and important.  Please see&#10;# http://httpd.apache.org/docs/2.2/mod/core.html#options&#10;# for more information.&#10;#&#10;    Options Indexes FollowSymLinks&#10;&#10;#&#10;# AllowOverride controls what directives may be placed in .htaccess files.&#10;# AllowOverride controls what directives may be placed in .htaccess files.&#10;# It can be &#34;All&#34;, &#34;None&#34;, or any combination of the keywords:&#10;#   Options FileInfo AuthConfig Limit&#10;#&#10;    AllowOverride All</span><br></pre></td></tr></table></figure>
<p>按照上面配置，再重启Apache即可。大功告成。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Ike本人在设置wordpress的时候，在settings里面发现了Permalink。从这个页面的主要介绍来看，Permalink的作用就是自定义文章的Link，使之更为结构化和友好。</p>
<p>但是当Ike设置了某个除Default之外的某个Permalink的时]]>
    </summary>
    
      <category term="Backend" scheme="http://wattlebird.github.io/tags/Backend/"/>
    
      <category term="apache" scheme="http://wattlebird.github.io/tags/apache/"/>
    
      <category term="wordpress" scheme="http://wattlebird.github.io/tags/wordpress/"/>
    
      <category term="Projects" scheme="http://wattlebird.github.io/categories/Projects/"/>
    
  </entry>
  
</feed>